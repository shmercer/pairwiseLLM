% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptive_run.R
\name{adaptive_rank_start}
\alias{adaptive_rank_start}
\title{Start an adaptive ranking run}
\usage{
adaptive_rank_start(
  samples,
  model,
  trait_name,
  trait_description,
  prompt_template = NULL,
  backend = NULL,
  mode = c("live", "batch"),
  submission = list(),
  adaptive = list(),
  paths = list(state_path = NULL, output_dir = NULL),
  seed = NULL
)
}
\arguments{
\item{samples}{A data frame or tibble with columns \code{ID} and \code{text}.}

\item{model}{Model identifier for the selected backend.}

\item{trait_name}{Short label for the trait.}

\item{trait_description}{Full-text trait description.}

\item{prompt_template}{Optional prompt template string. Defaults to
\code{set_prompt_template()}.}

\item{backend}{Backend name. For live mode: one of \code{"openai"},
\code{"anthropic"}, \code{"gemini"}, \code{"together"}, or \code{"ollama"}.
For batch mode: one of \code{"openai"}, \code{"anthropic"}, or
\code{"gemini"}.}

\item{mode}{Submission mode. Either \code{"live"} or \code{"batch"}.}

\item{submission}{A list of arguments passed through to
\code{submit_llm_pairs()} (live) or \code{llm_submit_pairs_multi_batch()}
(batch). Common options include \code{endpoint}, \code{include_raw},
\code{batch_size}, and \code{n_segments}.}

\item{adaptive}{A list of adaptive configuration overrides. Supported keys
include: \code{d1}, \code{bins}, \code{mix_struct},
\code{within_adj_split}, \code{exploration_frac}, \code{per_item_cap},
\code{n_draws_fast}, \code{batch_overrides}, \code{max_refill_rounds},
\code{max_replacements}, \code{max_iterations}, \code{budget_max}, and
\code{M1_target}.}

\item{paths}{A list with optional \code{state_path} and \code{output_dir}.
For batch mode, \code{state_path} defaults to
\code{file.path(output_dir, "adaptive_state.rds")}.}

\item{seed}{Optional integer seed for deterministic scheduling.}
}
\value{
A list with:
\describe{
\item{state}{The updated \code{adaptive_state}.}
\item{state_path}{Path where the state was saved (batch mode only).}
\item{submission_info}{Metadata needed for resume, including pairs submitted.}
\item{next_action}{List with \code{action} and \code{reason}.}
}
}
\description{
Initialize adaptive ranking, schedule Phase 1 pairs, and submit them in live
or batch mode. Live mode submits immediately and ingests observed outcomes.
Batch mode submits jobs, saves state, and returns resume metadata.
}
\details{
This is the entry point for adaptive ranking. It creates an
\code{adaptive_state} using the canonical schemas and schedules pairs using
Phase 1 logic until \code{M1_target} is met, then switches to adaptive
batches (Phase 2/3) on subsequent resumes. All results are normalized via
the shared normalization helper to ensure schema consistency.
}
\examples{
\dontrun{
samples <- tibble::tibble(
  ID = c("S1", "S2", "S3", "S4"),
  text = c("alpha", "bravo", "charlie", "delta")
)

td <- trait_description("overall_quality")
tmpl <- set_prompt_template()

# Live start (submits immediately and ingests observed results)
start_out <- adaptive_rank_start(
  samples = samples,
  model = "gpt-4.1",
  trait_name = td$name,
  trait_description = td$description,
  prompt_template = tmpl,
  backend = "openai",
  mode = "live",
  adaptive = list(d1 = 8, M1_target = 40),
  seed = 123
)

# Batch start (submits jobs and returns resume info)
batch_out <- adaptive_rank_start(
  samples = samples,
  model = "gpt-4.1",
  trait_name = td$name,
  trait_description = td$description,
  prompt_template = tmpl,
  backend = "openai",
  mode = "batch",
  submission = list(batch_size = 1000, write_registry = TRUE),
  paths = list(output_dir = "adaptive_runs"),
  adaptive = list(d1 = 8, M1_target = 40),
  seed = 123
)
}

}
