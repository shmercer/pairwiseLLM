% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/core_linking_pairs.R
\name{select_core_link_pairs}
\alias{select_core_link_pairs}
\title{Select core-linking pairs for BT scaling across batches/waves}
\usage{
select_core_link_pairs(
  samples,
  theta,
  core_ids,
  new_ids = NULL,
  round_size = 100,
  within_batch_frac = 0.25,
  core_audit_frac = 0.05,
  k_neighbors = 10,
  min_judgments = 12,
  existing_pairs = NULL,
  forbid_keys = character(0),
  forbid_repeats = TRUE,
  balance_positions = TRUE,
  seed = NULL
)
}
\arguments{
\item{samples}{A tibble/data.frame with columns \code{ID} and \code{text}.}

\item{theta}{A tibble/data.frame with columns \code{ID}, \code{theta}, \code{se}.
Rows may be missing for some IDs; missing \code{theta}/\code{se} are allowed.}

\item{core_ids}{Character vector of IDs designating the core set. Must be a
non-empty subset of \code{samples$ID}.}

\item{new_ids}{Optional character vector of IDs designating the "new batch".
If \code{NULL}, uses \code{setdiff(samples$ID, core_ids)}.}

\item{round_size}{Integer number of pairs to select. Can be \code{0}.}

\item{within_batch_frac}{Fraction (0..1) of non-audit pairs allocated to new↔new.}

\item{core_audit_frac}{Fraction (0..1) of pairs allocated to core↔core.}

\item{k_neighbors}{Integer controlling how strongly pairing is localized by}

\item{min_judgments}{Minimum number of total appearances (across both positions)
an item should have before it is deprioritized. Used as a soft priority rule.}

\item{existing_pairs}{Optional data.frame of already-judged pairs. Accepted column
schemas are either \code{ID1}/\code{ID2} or \code{object1}/\code{object2}.}

\item{forbid_keys}{Character vector of pair keys (as produced by \code{pair_key()}) that should not be proposed.
current \code{theta}: when both sides have non-missing \code{theta}, the
opponent is chosen from among the \code{k_neighbors} closest candidates.}

\item{forbid_repeats}{Logical; if \code{TRUE} (default) do not repeat unordered pairs.}

\item{balance_positions}{Logical; if \code{TRUE} (default), attempt to balance
first vs second position frequencies.}

\item{seed}{Optional integer seed. When provided, RNG state is restored to its
prior value (or returned to "uninitialized" if it was missing).}
}
\value{
A tibble with columns:
\itemize{
\item \code{ID1}, \code{ID2}: the pair (order reflects position balancing)
\item \code{pair_type}: one of \code{"core_new"}, \code{"new_new"}, \code{"core_core"}
}
}
\description{
Selects pairs intended to \strong{link a new batch} of samples to an existing
"core set" (core bank) so that BT ability estimates remain on a common scale
across waves/batches. Optionally, it can also select:
\itemize{
\item \strong{within-batch pairs} (new↔new) to improve local ordering of the new batch, and
\item \strong{core audit pairs} (core↔core) to monitor core stability over time.
}
}
\details{
This function does not run any LLM calls. It only proposes which pairs
should be judged next, given current BT estimates and constraints.

Pair selection is round-based. The requested \code{round_size} is split into:
\itemize{
\item \code{core_audit_frac} of pairs from core↔core,
\item \code{within_batch_frac} of remaining pairs from new↔new,
\item and the remainder from core↔new.
}

If \code{forbid_repeats = TRUE}, the function avoids generating unordered
duplicates that already exist in \code{existing_pairs} (and within the
newly selected round). If \code{balance_positions = TRUE}, it attempts to
keep items balanced in first vs second position across the accumulated
(existing + newly selected) pairs.
}
\examples{
# Minimal example using synthetic theta
samples <- tibble::tibble(
  ID = paste0("S", 1:12),
  text = paste("Text", 1:12)
)
theta <- tibble::tibble(
  ID = samples$ID,
  theta = rnorm(nrow(samples)),
  se = runif(nrow(samples), 0.2, 0.8)
)
core_ids <- paste0("S", 1:4)
pairs <- select_core_link_pairs(
  samples = samples,
  theta = theta,
  core_ids = core_ids,
  round_size = 10,
  seed = 1
)
pairs

}
