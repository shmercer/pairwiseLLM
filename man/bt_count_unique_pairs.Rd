% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run_metrics_helpers.R
\name{bt_count_unique_pairs}
\alias{bt_count_unique_pairs}
\title{Count unique unordered pairs for runner metrics}
\usage{
bt_count_unique_pairs(results, ids = NULL, new_ids = NULL)
}
\arguments{
\item{results}{A data frame with columns \code{ID1} and \code{ID2}.}

\item{ids}{Optional character vector defining the relevant ID universe. If
supplied, counts only include pairs where both endpoints are in \code{ids}.}

\item{new_ids}{Optional character vector of newly introduced IDs (core-linking
context). If supplied, \code{n_pairs_new} counts unique unordered pairs that
touch at least one ID in \code{new_ids}.}
}
\value{
A tibble with integer columns \code{n_pairs_total} and \code{n_pairs_new}.
If \code{new_ids} is \code{NULL}, \code{n_pairs_new} is returned as \code{NA}.
}
\description{
Runner functions in pairwiseLLM report pair-count metrics each round. This helper
computes schema-stable counts using a consistent definition across runners.
}
\details{
Semantics:
\itemize{
\item \code{n_pairs_total}: number of unique \emph{unordered} pairs observed so far,
optionally restricted to pairs where both endpoints lie in \code{ids}.
\item \code{n_pairs_new}: number of unique \emph{unordered} pairs observed so far
that involve at least one ID in \code{new_ids} (and, if \code{ids} is supplied,
also lie within \code{ids}).
}
}
\examples{
results <- tibble::tibble(
  ID1 = c("A", "B", "B", "A"),
  ID2 = c("B", "A", "C", "B")
)

# Unique unordered edges across all observed pairs
bt_count_unique_pairs(results)

# Count edges that involve at least one newly introduced ID
bt_count_unique_pairs(results, new_ids = "C")

# Restrict counting to a particular ID universe
bt_count_unique_pairs(results, ids = c("A", "B"))

}
