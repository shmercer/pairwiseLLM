% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptive_summaries.R
\name{summarize_refits}
\alias{summarize_refits}
\title{Summarize adaptive refits}
\usage{
summarize_refits(state, last_n = NULL, include_optional = TRUE)
}
\arguments{
\item{state}{An \code{adaptive_state} or list containing adaptive logs.}

\item{last_n}{Optional positive integer; return only the last \code{n} rows.}

\item{include_optional}{Logical; include optional diagnostic columns.}
}
\value{
A tibble with one row per refit (canonical \code{round_log} schema).
}
\description{
Build a thin per-refit diagnostics summary from the adaptive round log. This is
a pure view over \code{round_log} and does not recompute posterior
quantities or stop metrics.
}
\details{
The round log is the canonical stop-audit trail and groups fields by
identity/cadence, run-scale counts, design knobs, coverage/imbalance,
posterior percentiles, diagnostics, stop quality metrics,
stop decision, candidate health, and MCMC configuration. Run-scale counts
include \code{total_pairs} (\eqn{N(N-1)/2}), \code{hard_cap_threshold}
(\eqn{\lceil0.40 * total\_pairs\rceil}), \code{n_unique_pairs_seen} (unique
unordered pairs with \code{pair_count >= 1}), \code{scheduled_pairs},
\code{completed_pairs}, \code{backlog_unjudged} (scheduled minus completed),
\code{new_pairs} (newly completed since the previous refit), and
\code{proposed_pairs} (candidate unordered pairs evaluated at refit).
Percentile columns are fixed (e.g.,
\code{epsilon_p2.5}, \code{epsilon_p50}, \code{epsilon_p97.5}) and remain
present with \code{NA} values when a parameter is not part of a model
variant. Stopping metrics report posterior quality (e.g.,
\code{reliability_EAP}) and stability checks (e.g.,
\code{rank_stability_pass}) without recomputation. See
\code{adaptive_rank_start()} for the full \code{round_log} column
definitions.
}
\examples{
# These summaries work on either an adaptive_state or a plain list of logs.
logs <- list(
  round_log = tibble::tibble(
    round_id = 1:2,
    iter_at_refit = c(10L, 20L),
    new_pairs = c(50L, 50L),
    completed_pairs = c(50L, 100L),
    divergences = c(0L, 0L),
    max_rhat = c(1.01, 1.00),
    min_ess_bulk = c(800, 900),
    stop_decision = c(NA, TRUE),
    stop_reason = c(NA_character_, "quality_threshold_met"),
    mode = "live"
  )
)

# Full per-refit view:
summarize_refits(logs)

# Only the most recent refit row:
summarize_refits(logs, last_n = 1)

# Drop optional diagnostics if you want a compact core summary:
summarize_refits(logs, include_optional = FALSE)

}
