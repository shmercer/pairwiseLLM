% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptive_run.R
\name{adaptive_rank_run_live}
\alias{adaptive_rank_run_live}
\title{Run an adaptive ranking session in live mode (with optional auto-resume)}
\usage{
adaptive_rank_run_live(
  samples,
  model,
  trait_name,
  trait_description,
  prompt_template = NULL,
  backend = NULL,
  submission = list(),
  adaptive = list(),
  paths = list(state_path = NULL, output_dir = NULL),
  seed = NULL,
  max_iterations = NULL,
  resume = c("auto", "never", "always"),
  resume_validate = c("strict", "warn", "none")
)
}
\arguments{
\item{samples}{A data frame / tibble of items to rank. Must include an \code{ID}
column (character/integer) that uniquely identifies each item. Any other
columns are preserved in the state and can be used by prompt templates.}

\item{model}{Model identifier used by the live backend (e.g. \code{"gpt-4.1-mini"}).}

\item{trait_name}{Short name of the trait being judged.}

\item{trait_description}{Longer description/instructions for the trait.}

\item{prompt_template}{Optional prompt template override. If \code{NULL}, a default
template is used.}

\item{backend}{Backend identifier for live judging (e.g. \code{"openai"}). If \code{NULL}
and resuming, the checkpoint's backend is used.}

\item{submission}{List of live submission options (parallelism, verbosity, etc.).
Passed through to internal submission helpers.}

\item{adaptive}{List of adaptive configuration overrides. Merged with defaults
by \code{.adaptive_merge_config()}.}

\item{paths}{A list with entries \code{state_path} and \code{output_dir}. If \code{state_path}
is provided, the run state will be checkpointed there after each resume step.}

\item{seed}{Optional integer seed for reproducibility.}

\item{max_iterations}{Optional safety cap on the number of wrapper iterations.
If \code{NULL}, uses the configured default (no cap). Use \code{Inf} (or
\code{adaptive$max_iterations = NULL}) for no cap.}

\item{resume}{Controls checkpoint resume behavior. One of:
\describe{
\item{\code{"auto"}}{Resume if \code{paths$state_path} exists; otherwise start new.}
\item{\code{"never"}}{Always start a new run even if a checkpoint exists.}
\item{\code{"always"}}{Require a checkpoint at \code{paths$state_path}; error if missing.}
}}

\item{resume_validate}{How strictly to validate that \code{samples} match the checkpoint
when resuming. One of:
\describe{
\item{\code{"strict"}}{IDs must exist and match exactly (including order); otherwise error.}
\item{\code{"warn"}}{If mismatch, warn and start a new run (equivalent to \code{resume="never"} for this call).}
\item{\code{"none"}}{Skip validation (not recommended; can corrupt runs if samples differ).}
}}
}
\value{
A list with:
\describe{
\item{\code{state}}{The current adaptive state (checkpointable).}
\item{\code{submission_info}}{Submission metadata used for the last step.}
\item{\code{next_action}}{Next action requested by the engine (e.g., \code{"resume"} or stop).}
\item{\code{iterations}}{Number of wrapper iterations executed in this call.}
\item{\code{resumed}}{Logical, whether the call resumed from checkpoint.}
}
}
\description{
This is a high-level convenience wrapper around the adaptive v3 engine for
\emph{live} judging (e.g., via an LLM backend). It starts a new run (default) or,
if configured, automatically resumes from an on-disk checkpoint when one is
present at \code{paths$state_path}.
}
\details{
\subsection{Iterations vs. statistical stopping}{

\code{adaptive_rank_run_live()} runs a loop of \strong{adaptive iterations} (each
iteration schedules/collects a batch of comparisons) until either:
\itemize{
\item the adaptive engine returns a non-\code{"resume"} next action (e.g. stopped),
\item or the wrapper hits \code{max_iterations} (a safety cap; defaults to no cap).
}

The Bayesian stopping criteria (diagnostics, reliability, stability) are
evaluated at refits, but this wrapper can still terminate early if it hits
the iteration cap. Set \code{max_iterations} if you want the run to continue
until statistical stopping is reached.
}

\subsection{Auto-resume behavior}{

When \code{resume = "auto"} (default), and \code{paths$state_path} points to an existing
checkpoint file, this function resumes that run instead of starting a new one.
By default it performs a strict identity check that the provided \code{samples}
match the checkpoint's items (IDs and order).
}
}
\examples{
\dontrun{
# --- Start a new live run ---
out <- adaptive_rank_run_live(
  samples = samples,
  model = "gpt-4.1-mini",
  trait_name = "Overall Quality",
  trait_description = "Choose the better of the two responses for overall quality.",
  backend = "openai",
  seed = 123,
  submission = list(parallel = TRUE, workers = 8, progress = TRUE, verbose = TRUE),
  paths = list(
    state_path = "./dev-output/adaptive_gpt4.1-mini/state.rds",
    output_dir  = "./dev-output/adaptive_gpt4.1-mini"
  ),
  max_iterations = 50
)

# --- Resume automatically (same call, same state_path) ---
# This will continue from the saved checkpoint (iter 51, etc.) if it exists.
out2 <- adaptive_rank_run_live(
  samples = samples,
  model = "gpt-4.1-mini",
  trait_name = "Overall Quality",
  trait_description = "Choose the better of the two responses for overall quality.",
  backend = "openai",
  seed = 123,
  submission = list(parallel = TRUE, workers = 8, progress = TRUE, verbose = TRUE),
  paths = list(
    state_path = "./dev-output/adaptive_gpt4.1-mini/state.rds",
    output_dir  = "./dev-output/adaptive_gpt4.1-mini"
  ),
  max_iterations = 200,
  resume = "auto",
  resume_validate = "strict"
)

# --- Require a checkpoint and fail if missing ---
out3 <- adaptive_rank_run_live(
  samples = samples,
  model = "gpt-4.1-mini",
  trait_name = "Overall Quality",
  trait_description = "Choose the better of the two responses for overall quality.",
  backend = "openai",
  paths = list(state_path = "./dev-output/adaptive_gpt4.1-mini/state.rds"),
  resume = "always"
)
}
}
