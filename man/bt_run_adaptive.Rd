% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bt_run_adaptive.R
\name{bt_run_adaptive}
\alias{bt_run_adaptive}
\title{Run a round-based adaptive BT workflow end-to-end}
\usage{
bt_run_adaptive(
  samples,
  judge_fun,
  initial_results = NULL,
  judge = NULL,
  engine = "sirt",
  fit_verbose = FALSE,
  return_diagnostics = TRUE,
  include_residuals = FALSE,
  fit_engine_running = c("rank_centrality", "bt", "hybrid"),
  rc_smoothing = 0.5,
  rc_damping = 0,
  stage1_k_conn = 2L,
  stage1_k_stab = 3L,
  stage1_min_pct_nodes_with_degree_gt0 = 0.95,
  stage1_min_largest_component_frac = 0.95,
  stage1_min_degree_median = 2,
  stage1_min_degree_min_lcc = 1,
  stage1_min_degree_min = 0,
  stage1_min_spearman = 0.97,
  stage1_stability_metric = c("topk_jaccard", "spearman"),
  stage1_topk = NULL,
  stage1_topk_overlap = 0.85,
  stage1_allow_degenerate_stability = FALSE,
  stage1_max_rounds = 10L,
  stage1_max_bridge_edge_frac = 0.02,
  stage1_k_mix = 2L,
  stage1_check_mix_every = 2L,
  stage1_escalated_explore_frac = 0.5,
  stage1_escalated_k_neighbors = Inf,
  stage1_escalate_allow_unordered_repeats = FALSE,
  stage1_explore_frac = 0.25,
  stage2_explore_frac = 0.1,
  stage2_min_rounds = 3L,
  final_refit = TRUE,
  fit_engine_final = c("bt_firth", "bt_mle", "bt_bayes", "none"),
  final_bt_bias_reduction = TRUE,
  round_size = 50,
  init_round_size = round_size,
  max_rounds = 50,
  se_probs = c(0.5, 0.9, 0.95),
  fit_bounds = c(0.7, 1.3),
  stopping_tier = c("strong", "good", "very_strong"),
  reliability_target = 0.9,
  sepG_target = 3,
  rel_se_p90_target = 0.3,
  rel_se_p90_min_improve = 0.01,
  max_item_misfit_prop = 0.05,
  max_judge_misfit_prop = 0.05,
  k_neighbors = 10,
  min_judgments = 12,
  repeat_policy = "reverse_only",
  repeat_cap = 1L,
  repeat_frac = 0.05,
  repeat_n = NULL,
  repeat_guard_min_degree = 1L,
  repeat_guard_largest_component_frac = 0.9,
  forbid_repeats = NULL,
  balance_positions = TRUE,
  embeddings = NULL,
  embed_k = 30,
  embed_far_k = 0,
  seed_pairs = NULL,
  min_rounds = 2L,
  stop_stability_rms = 0.01,
  stop_topk = 50L,
  stop_topk_overlap = 0.95,
  stop_min_largest_component_frac = NA_real_,
  stop_min_degree = NA_integer_,
  stop_reason_priority = NULL,
  stop_stability_consecutive = 2L,
  stop_max_bridge_edge_frac = 0.02,
  stop_k_mix = NULL,
  stop_check_mix_every = 2L,
  spectral_gap_check = c("never", "final", "pre_stop", "pre_switch_and_final"),
  spectral_gap_weights = c("count", "binary"),
  spectral_gap_max_iter = 200L,
  spectral_gap_tol = 1e-06,
  spectral_gap_warn_below = 0.01,
  stop_topk_ties = c("id", "random"),
  fit_fun = fit_bt_model,
  build_bt_fun = build_bt_data,
  checkpoint_dir = NULL,
  resume_from = NULL,
  checkpoint_every = 1L,
  checkpoint_store_fits = TRUE,
  checkpoint_overwrite = TRUE,
  embed_quota_frac = 0.25,
  candidate_pool_cap = Inf,
  per_anchor_cap = Inf,
  w_embed = 1,
  embed_score_mode = "rank_decay",
  ...
)
}
\arguments{
\item{samples}{A tibble/data.frame with columns \code{ID} and \code{text}.
\code{ID} must be unique and non-missing; \code{text} is the content shown to the judge.}

\item{judge_fun}{A function that accepts a tibble of pairs with columns
\code{ID1}, \code{text1}, \code{ID2}, \code{text2} and returns a tibble with
columns \code{ID1}, \code{ID2}, and \code{better_id}.
If \code{judge} is provided, the returned tibble must also include that judge column.
\code{better_id} may be returned as the literal winning ID (\code{ID1} or \code{ID2})
or as common positional labels (e.g., \code{SAMPLE_1}/\code{SAMPLE_2},
\code{ID1}/\code{ID2}, \code{1}/\code{2}, \code{0}/\code{1}, \code{A}/\code{B},
\code{LEFT}/\code{RIGHT}); these are normalized to the corresponding IDs.
Blank/NA-like winners are treated as missing (\code{NA}) and are ignored in scoring.}

\item{initial_results}{Optional tibble/data.frame of already-scored pairs with columns
\code{ID1}, \code{ID2}, \code{better_id} (and optional judge column). When provided,
these results are used as the starting state (and no bootstrap is performed unless
\code{initial_results} is empty).}

\item{judge}{Optional character scalar giving the name of the column in results that
identifies the judge/backend/model (e.g., \code{"gpt4o"} vs \code{"claude"}).
When provided, the column must be present in outputs from \code{judge_fun} and is
passed to \code{\link{build_bt_data}} so engines that support judge effects can use it.}

\item{engine}{Character scalar passed to \code{fit_fun} as its \code{engine} argument.
Default \code{"sirt"}.}

\item{fit_verbose}{Logical; passed to \code{fit_fun} as \code{verbose}. Default \code{FALSE}.}

\item{return_diagnostics}{Logical; passed to \code{fit_fun}. If \code{TRUE}, attempt to
return engine-specific diagnostics (e.g., item fit, separation/reliability). Default \code{TRUE}.}

\item{include_residuals}{Logical; passed to \code{fit_fun}. If \code{TRUE}, request
residual/probability outputs when supported (may increase compute/memory). Default \code{FALSE}.}

\item{fit_engine_running}{Character. Estimator used for the \emph{running} ability
vector that drives adaptive pair selection.

\describe{\item{\code{"bt"}}{Use the BT fit returned by \code{fit_fun}.}}
\describe{\item{\code{"rank_centrality"}}{Compute Rank Centrality scores from the
current comparison graph (often more stable early on sparse graphs) while still
using BT standard errors as an uncertainty heuristic when available.}}
\describe{\item{\code{"hybrid"}}{Start with Rank Centrality as the running ability
estimate, then switch to BT once the graph is sufficiently connected and Rank
Centrality ranks are stable. See \code{stage1_*} controls.}}

Default \code{"bt"}.}

\item{rc_smoothing}{Numeric. Smoothing parameter forwarded to
\code{\link{fit_rank_centrality}} when
\code{fit_engine_running = "rank_centrality"} (and stored in per-round fits).
See \code{\link{fit_rank_centrality}}.}

\item{rc_damping}{Numeric. Damping parameter forwarded to
\code{\link{fit_rank_centrality}} when
\code{fit_engine_running = "rank_centrality"} (and stored in per-round fits).
See \code{\link{fit_rank_centrality}}.}

\item{stage1_k_conn}{Integer. For \code{fit_engine_running = "hybrid"}, require the
connectivity gate to hold for this many consecutive rounds before allowing a stage
switch.}

\item{stage1_k_stab}{Integer. For \code{fit_engine_running = "hybrid"}, require the
stage-1 stability gate (as defined by \code{stage1_stability_metric}) to hold for this
many consecutive rounds before allowing a stage switch.}

\item{stage1_min_pct_nodes_with_degree_gt0}{Numeric in \code{[0, 1]}. For
\code{fit_engine_running = "hybrid"}, minimum fraction of nodes that have appeared in
at least one comparison (degree > 0) for the connectivity gate.}

\item{stage1_min_largest_component_frac}{Numeric in \code{[0, 1]}. For
\code{fit_engine_running = "hybrid"}, minimum fraction of nodes in the largest
connected component for the connectivity gate.}

\item{stage1_min_degree_median}{Numeric. For \code{fit_engine_running = "hybrid"},
minimum median node degree for the connectivity gate.}

\item{stage1_min_degree_min_lcc}{Numeric. For \code{fit_engine_running = "hybrid"},
minimum node degree within the largest connected component (LCC) for the
connectivity gate.}

\item{stage1_min_degree_min}{Numeric. (Deprecated) For
\code{fit_engine_running = "hybrid"}, minimum node degree over \emph{all} nodes
for the connectivity gate. This can effectively force 100\% coverage when any node
is still unseen (degree 0). Prefer \code{stage1_min_degree_min_lcc}.}

\item{stage1_min_spearman}{Numeric. For \code{fit_engine_running = "hybrid"}, minimum
Spearman correlation between consecutive RC rank vectors to count as stable.}

\item{stage1_stability_metric}{Character. For \code{fit_engine_running = "hybrid"},
which stability metric to use in stage1 when deciding whether to switch to BT.
One of \code{"topk_jaccard"} (top-\code{k} overlap on RC ranks) or \code{"spearman"}
(Spearman correlation of RC ranks). Default \code{"topk_jaccard"}.}

\item{stage1_topk}{Integer or \code{NULL}. For \code{stage1_stability_metric = "topk_jaccard"},
the \code{k} used for the top-\code{k} overlap check. If \code{NULL} (default),
uses \code{max(10, ceiling(0.1 * N))} where \code{N = nrow(samples)}.}

\item{stage1_topk_overlap}{Numeric in \code{[0, 1]}. For
\code{stage1_stability_metric = "topk_jaccard"}, minimum top-\code{k} overlap fraction
between consecutive RC rounds required to count as stable. Default \code{0.85}.}

\item{stage1_allow_degenerate_stability}{Logical. If \code{FALSE} (default), degenerate
RC ranks (e.g., constant/undefined Spearman) do not count as stable in stage1.
If \code{TRUE}, degenerate stability is treated as perfectly stable (legacy behavior).}

\item{stage1_max_rounds}{Integer. For \code{fit_engine_running = "hybrid"}, maximum
number of Stage 1 rounds to attempt before triggering stage-1 fail-safe escalation.}

\item{stage1_max_bridge_edge_frac}{Numeric in \code{[0, 1]}. For \code{fit_engine_running = "hybrid"},
additional mixing-guard threshold on the bridge-edge fraction proxy (computed only on scheduled
checks). Stage1 can switch to BT only when \code{bridge_edge_frac <= stage1_max_bridge_edge_frac}
for \code{stage1_k_mix} consecutive checks. Default \code{0.02}.}

\item{stage1_k_mix}{Integer. For \code{fit_engine_running = "hybrid"}, number of consecutive
mixing checks that must pass before switching stage1\eqn{\to}stage2. Default \code{2}.}

\item{stage1_check_mix_every}{Integer. For \code{fit_engine_running = "hybrid"}, compute the bridge-edge
fraction proxy every \code{stage1_check_mix_every} rounds (to reduce runtime). Default \code{2}.}

\item{stage1_escalated_explore_frac}{Numeric in \code{[0, 1]}. For \code{fit_engine_running = "hybrid"},
when Stage 1 reaches \code{stage1_max_rounds} without meeting the connectivity gate,
increase exploration to at least this fraction. Default \code{0.5}.}

\item{stage1_escalated_k_neighbors}{Integer (or \code{NULL}/\code{Inf}). For \code{fit_engine_running = "hybrid"},
when Stage 1 reaches \code{stage1_max_rounds} without meeting the connectivity gate,
expand neighbor windows by setting \code{k_neighbors} to at least this value.
Use \code{Inf} for "all neighbors". Default \code{Inf}.}

\item{stage1_escalate_allow_unordered_repeats}{Logical. For \code{fit_engine_running = "hybrid"},
when Stage 1 is escalated, optionally allow unordered repeats to avoid a hard
\code{"no_new_pairs"} stop when constraints are too restrictive. Default \code{FALSE}.}

\item{stage1_explore_frac}{Fraction of each round reserved for exploration while in stage1 (hybrid only).}

\item{stage2_explore_frac}{Fraction of each round reserved for exploration while in stage2 (hybrid only).}

\item{stage2_min_rounds}{Minimum number of BT rounds to run after switching to stage2 before allowing precision/stability stops.}

\item{final_refit}{Logical. If \code{TRUE} (default), compute a final combined
estimates table (Rank Centrality plus optional BT variants) at the end of the
run via \code{\link{compute_final_estimates}}. Suggested dependencies are
used when available; if unavailable or if a BT fit fails, the function falls
back to Rank Centrality and records the reason in \code{out$fit_provenance}.}

\item{fit_engine_final}{Preferred final BT engine used when \code{final_refit = TRUE}.
Options are \code{"bt_firth"}, \code{"bt_mle"}, \code{"bt_bayes"}, and \code{"none"}.
See \code{\link{compute_final_estimates}} for details. Default \code{"bt_firth"}.}

\item{final_bt_bias_reduction}{Logical. Passed to \code{\link{compute_final_estimates}}
as \code{bt_bias_reduction}. Default \code{TRUE}. Typically leave \code{TRUE}
when \code{fit_engine_final = "bt_firth"}.}

\item{round_size}{Integer. Number of new pairs to propose and score in each adaptive round.
If \code{0}, the runner will fit once (if possible) and then stop without proposing new pairs.}

\item{init_round_size}{Integer. Number of bootstrap (random) pairs to score before the first
model fit when \code{initial_results} is \code{NULL} or empty. Default: \code{round_size}.}

\item{max_rounds}{Integer. Maximum number of adaptive rounds to run (excluding the bootstrap
scoring step). Default \code{50}.}

\item{se_probs}{Numeric vector of probabilities in \code{[0, 1]} used when summarizing the
distribution of standard errors for stopping diagnostics (e.g., median, 90th percentile).
Passed to \code{\link{bt_adaptive_round}}.}

\item{fit_bounds}{Numeric length-2 vector giving lower/upper acceptable
infit/outfit bounds when available. Passed to \code{\link{bt_adaptive_round}}.}

\item{stopping_tier}{Preset stopping thresholds to use
(good/strong/very_strong) when available. Passed to
\code{\link{bt_adaptive_round}}.}

\item{reliability_target}{Numeric. Target reliability/separation-based criterion used by
\code{\link{bt_adaptive_round}} for stopping decisions.}

\item{sepG_target}{Numeric. Target separation index (or analogous) used by
\code{\link{bt_adaptive_round}} for stopping decisions.}

\item{rel_se_p90_target}{Numeric. Target value for the 90th percentile of item SE (or a
comparable uncertainty summary) used for stopping. Passed to \code{\link{bt_adaptive_round}}.}

\item{rel_se_p90_min_improve}{Numeric. Minimum required improvement in the uncertainty summary
relative to the previous round; if improvement falls below this, stopping may be allowed
(depending on other criteria). Passed to \code{\link{bt_adaptive_round}}.}

\item{max_item_misfit_prop}{Numeric between 0 and 1 (inclusive). Maximum
allowed proportion of item misfit flags
(based on \code{fit_bounds}/diagnostics) before stopping is disallowed. Passed to
\code{\link{bt_adaptive_round}}.}

\item{max_judge_misfit_prop}{Numeric between 0 and 1 (inclusive). Maximum
allowed proportion of judge misfit flags before stopping is disallowed
(when judge diagnostics are available). Passed to \code{\link{bt_adaptive_round}}.}

\item{k_neighbors}{Integer. When ability estimates are available, restrict candidate pair
selection to approximately local neighborhoods in \code{theta} (e.g., near neighbors) to focus
comparisons where they are most informative. If \code{theta} is not available (early rounds),
selection falls back to non-theta heuristics. Passed to \code{\link{bt_adaptive_round}} /
\code{\link{select_adaptive_pairs}}.}

\item{min_judgments}{Integer. Minimum number of total judgments per item to prioritize before
focusing on adaptive informativeness/uncertainty. Passed to \code{\link{bt_adaptive_round}}.}

\item{repeat_policy}{Character repeat planning policy. Options:
\itemize{
\item \code{"none"}: do not plan repeat checks.
\item \code{"reverse_only"}: plan a subset of opposite-direction repeats for
eligible unordered pairs (A,B).
\item \code{"forbid_unordered"}: convenience alias that behaves like the
legacy \code{forbid_repeats = TRUE} (no planned repeats and forbids
selecting unordered repeats from the candidate pool).
}}

\item{repeat_cap}{Non-negative integer cap on the number of planned repeat
pairs per unordered pair key. For \code{repeat_policy = "reverse_only"}, each
unordered pair is eligible for at most \code{repeat_cap} planned reverse
repeats.}

\item{repeat_frac}{Numeric in \code{[0, 1]}. Target fraction of the requested
per-round \code{round_size} pairs that should be reserved for repeat checks
(when eligible repeat pairs exist).}

\item{repeat_n}{Optional non-negative integer. If provided, overrides
\code{repeat_frac} and targets this many planned repeat pairs per round.}

\item{repeat_guard_min_degree}{Integer. Guard for enabling repeat planning:
do not plan repeats until the minimum graph degree across IDs is at least
this value.}

\item{repeat_guard_largest_component_frac}{Numeric in \code{[0, 1]}. Guard for
enabling repeat planning: do not plan repeats until the largest connected
component contains at least this fraction of IDs.}

\item{forbid_repeats}{Logical. If \code{TRUE}, unordered pairs (A,B) are not repeated across
rounds. Passed to \code{\link{bt_adaptive_round}} / \code{\link{select_adaptive_pairs}}.}

\item{balance_positions}{Logical. If \code{TRUE}, attempt to balance how often each item appears
in the first vs second position (\code{ID1} vs \code{ID2}) to mitigate positional bias.
Passed to \code{\link{bt_adaptive_round}} / \code{\link{select_adaptive_pairs}}.}

\item{embeddings}{Optional numeric embeddings matrix with one row per item.
If provided, adaptive candidate generation is augmented with embedding-based
neighbor candidates (in addition to theta-neighbors). Use
\code{\link{validate_embeddings}} to align/reorder rows.}

\item{embed_k}{Integer. Number of nearest neighbors (by cosine similarity) to
precompute per item from \code{embeddings}. Only used when \code{embeddings}
is provided.}

\item{embed_far_k}{Integer. Number of additional "far" candidates to sample
per item (uniformly at random) to preserve global mixing. Only used when
\code{embeddings} is provided.}

\item{seed_pairs}{Optional integer seed used for bootstrap pair generation as
\code{seed_pairs}, and for adaptive rounds as \code{seed_pairs + round}.
The RNG state is restored to its prior value (or returned to "uninitialized" if it was missing).
Note: this controls pair selection reproducibility; it does not control randomness inside
\code{judge_fun} unless your \code{judge_fun} uses it explicitly.

(RNG state is restored afterward).}

\item{min_rounds}{Integer. Minimum number of adaptive rounds to run before allowing
stability- or precision-based stopping. Hard stops (no new pairs, budget exhausted,
max rounds) can still terminate earlier. Default \code{2}.}

\item{stop_stability_rms}{Numeric. Threshold on RMS change in \code{theta} between consecutive
fits; lower values indicate greater stability. Default \code{0.01}.}

\item{stop_topk}{Integer. Size \code{k} for the top-\code{k} overlap stability check. Default \code{50}.}

\item{stop_topk_overlap}{Numeric in \code{[0, 1]}. Minimum overlap fraction between consecutive top-\code{k}
sets required to consider rankings stable. Default \code{0.95}.}

\item{stop_min_largest_component_frac}{Numeric in \code{[0, 1]}. Minimum fraction of nodes that must lie in the
largest connected component for the comparison graph to be considered healthy. The formal argument default is \code{NA}, but when left \code{NA} the runner applies an internal effective default of \code{0.98} (unless overridden). Set explicitly (e.g., \code{0}) to disable this gating.}

\item{stop_min_degree}{Integer. Minimum node degree required for the comparison graph to be considered
healthy. The formal argument default is \code{NA}, but when left \code{NA} the runner applies an internal effective default of \code{1} (unless overridden). Set explicitly (e.g., \code{0L}) to disable this gating.}

\item{stop_reason_priority}{Optional character vector specifying a priority order for stop reasons when
multiple stopping criteria are met on the same round. If \code{NULL}, a default priority is used.}

\item{stop_stability_consecutive}{Integer. Number of consecutive rounds the stability criteria
must hold before stopping. Default \code{2}.}

\item{stop_max_bridge_edge_frac}{Numeric in \code{[0, 1]}. Additional mixing guard for stopping: when the
comparison graph is otherwise healthy, stopping is only allowed once the bridge-edge fraction proxy
is at most this value for \code{stop_k_mix} consecutive checks. Set to \code{NA} to disable. Default \code{0.02}.}

\item{stop_k_mix}{Integer. Number of consecutive mixing checks that must pass before allowing stopping.
Default \code{2}.}

\item{stop_check_mix_every}{Integer. Compute the bridge-edge fraction proxy every
\code{stop_check_mix_every} rounds (to reduce runtime). Default \code{2}.}

\item{spectral_gap_check}{Character. Optional end-of-run (and optionally pre-stop/pre-switch) spectral
gap check on a lazy random walk over the comparison graph. Values:
\itemize{
\item \code{"never"}: do not compute.
\item \code{"final"}: compute once at the end.
\item \code{"pre_stop"}: compute immediately before stopping (when a stop would occur) and at the end.
\item \code{"pre_switch_and_final"}: compute immediately before switching stage1\eqn{\to}stage2 and at the end.
}
This check is non-blocking by default; it is recorded in \code{out$spectral_gap_checks}.}

\item{spectral_gap_weights}{Character. Edge weighting scheme for the spectral-gap estimator:
\code{"count"} (use edge multiplicity) or \code{"binary"} (unweighted). Default \code{"count"}.}

\item{spectral_gap_max_iter}{Integer. Maximum iterations for the spectral-gap estimator. Default \code{200}.}

\item{spectral_gap_tol}{Numeric. Convergence tolerance for the spectral-gap estimator. Default \code{1e-6}.}

\item{spectral_gap_warn_below}{Numeric in \code{[0, 1]}. Threshold below which \code{spectral_gap_warn = TRUE}
is recorded in \code{out$spectral_gap_checks}. Default \code{0.01}.}

\item{stop_topk_ties}{Character. How to handle ties at the \code{k}-th boundary for the top-\code{k}
overlap check. One of \code{"id"} (deterministic) or \code{"random"}. Default \code{"id"}.}

\item{fit_fun}{Function used to fit the BT model. Default \code{\link{fit_bt_model}}.
Primarily intended as a test hook; most users should keep the default.}

\item{build_bt_fun}{Function used to convert results into BT data. Default
\code{\link{build_bt_data}}. Primarily intended as a test hook.}

\item{checkpoint_dir}{Optional directory path for writing checkpoint files during
a run. If provided, the runner writes a checkpoint file named
\code{run_state.rds} (and optionally per-round snapshot files) after completed
rounds. Use this to resume long jobs after interruption or errors.}

\item{resume_from}{Optional directory path containing a prior checkpoint file
\code{run_state.rds} created by \code{bt_run_adaptive()}. When provided, the
run resumes from the saved state (including accumulated results and round
counters) rather than starting from scratch. The \code{samples} argument must
match the checkpoint's sample IDs (and typically the same runner configuration
should be used).}

\item{checkpoint_every}{Integer controlling how frequently per-round snapshot
checkpoint files are written. A value of \code{1} writes a snapshot after every
completed round; a value of \code{2} writes snapshots every other round, etc.
The main file \code{run_state.rds} is still updated at safe points even when
\code{checkpoint_every > 1}.}

\item{checkpoint_store_fits}{Logical indicating whether to store fitted model
objects (e.g., BT model fits and diagnostics) inside checkpoint files. Set to
\code{FALSE} to reduce checkpoint size and speed up checkpoint writes; in that
case, model fits will be recomputed as needed after resuming.}

\item{checkpoint_overwrite}{Logical indicating whether to overwrite an existing
\code{run_state.rds} file in \code{checkpoint_dir}. If \code{FALSE} and a
checkpoint file already exists, the function should error rather than overwrite.}

\item{embed_quota_frac}{Numeric in \code{[0, 1]}. Minimum fraction of selected pairs
that should come from embedding-neighbor candidates when embeddings are used.}

\item{candidate_pool_cap}{Non-negative integer or Inf. Global cap on the size
of the candidate pool considered during pair selection.}

\item{per_anchor_cap}{Non-negative integer or Inf. Per-item cap on the number
of candidates retained (after scoring) for each anchor item.}

\item{w_embed}{Non-negative numeric. Optional weight on an embedding-source bonus
term used in candidate scoring.}

\item{embed_score_mode}{Character. How to compute the embedding-source bonus.}

\item{...}{Additional arguments passed through to \code{fit_fun}.}
}
\value{
A list with elements:
\describe{
\item{results}{All accumulated forward-direction results (ID1, ID2, better_id, ...).}
\item{bt_data}{BT data built from \code{results}.}
\item{fits}{List of per-round fit objects (one per adaptive round). Each fit is
tagged with per-round metadata in the \code{attr(fit, "bt_run_adaptive")} attribute.}
\item{final_fit}{The final fit object (the last element of \code{fits}), or \code{NULL}
if no fit was run.}
\item{theta}{A compact tibble with columns \code{ID}, \code{theta}, \code{se}, and
\code{rank}, representing the final ability scale used for most downstream workflows.
When a BT final fit succeeds, this corresponds to the final BT scale; otherwise it
falls back to Rank Centrality.}
\item{theta_engine}{A single string describing which engine produced \code{theta}
(e.g., \code{"bt_firth"}, \code{"bt_mle"}, \code{"bt_bayes"}, \code{"rank_centrality"}).}
\item{estimates}{NULL unless \code{final_refit=TRUE}; then a final combined estimates
tibble produced by \code{\link{compute_final_estimates}} (BT + Rank Centrality).}
\item{final_models}{NULL unless \code{final_refit=TRUE}; then a list containing
the fitted model objects (\code{bt_fit}, \code{rc_fit}) and a summary \code{diagnostics} list.}
\item{fit_provenance}{NULL unless \code{final_refit=TRUE}; then a list describing which
final engines were requested and used, including any fallback reason.}
\item{stop_reason}{A single string describing why the loop ended.
Standard reasons include: \code{"stability_reached"}, \code{"precision_reached"},
\code{"no_new_pairs"}, \code{"pair_budget_exhausted"}, and \code{"max_rounds_reached"}.}
\item{stop_round}{Integer round index at which the loop ended (\code{NA} if no rounds were run).}
\item{rounds}{A tibble summarizing each adaptive round (metrics + stop flag + stop_reason).}
\item{state}{A tibble with one row per adaptive round containing bookkeeping summaries
of the accumulated results at that round (e.g., \code{n_unique_unordered_pairs},
appearance quantiles, \code{pos_imbalance_max}, \code{n_self_pairs},
\code{n_missing_better_id}), plus \code{round}, \code{stop}, and \code{stop_reason}.}
\item{pairs_bootstrap}{Pairs used in the bootstrap scoring step (may be empty).}
\item{run_summary}{One row tibble summarizing the run.}
\item{metrics}{One row per round of schema-stable diagnostic metrics.}
\item{pairing_diagnostics}{Planned and derived pairing diagnostics per round, including
whether selection fell back to controlled-random pairing (via
\code{fallback_path == "controlled_random"}) and its trigger
(\code{fallback_trigger}).}
\item{spectral_gap_checks}{Optional spectral-gap check results (computed at the end and/or on demand).}
}
}
\description{
This exported runner implements the core adaptive loop:
\enumerate{
\item propose pairs (initial random bootstrap, then adaptive),
\item score pairs using a provided judge function (LLM/human/simulator),
\item append results,
\item fit a BT model,
\item compute stopping metrics and decide whether to stop,
\item repeat until stopping criteria are met or \code{max_rounds} is reached.
}
}
\details{
In addition to per-round stop metrics, \code{bt_run_adaptive()} records a compact
per-round \emph{state snapshot} (counts of unique unordered pairs judged, ID appearance
distribution, position imbalance, and basic missingness checks). This is intended for
debugging and monitoring convergence/coverage over rounds.

\strong{No reverse-order checks during adaptive sampling.}
Optionally, after stopping (or hitting \code{max_rounds}), you can run a
post-hoc reverse-order audit on a random subset of already-judged pairs and
compute forward-vs-reverse consistency via \code{\link{compute_reverse_consistency}}.

The default modeling function is \code{\link{fit_bt_model}} and the default
stopping+pairing helper is \code{\link{bt_adaptive_round}}.

\strong{Checkpointing and resuming:} If \code{checkpoint_dir} is provided, this
function writes a checkpoint representing the \emph{last completed safe point}
of the adaptive loop (i.e., after a round has fully completed). If the run is
interrupted or errors occur mid-round, the checkpoint corresponds to the most
recently completed round. Resume by calling the function again with
\code{resume_from = checkpoint_dir} (and typically the same key settings such as
\code{round_size}, repeat controls, and selection strategy).
}
\examples{
# Minimal self-contained example that does not require sirt:
samples <- tibble::tibble(
  ID = c("A", "B", "C", "D"),
  text = paste("text", c("A", "B", "C", "D"))
)

# A tiny "judge" simulator (deterministic by latent ability):
true_theta <- c(A = 2, B = 1, C = 0, D = -1)
judge_fun <- function(pairs) {
  simulate_bt_judge(pairs, true_theta = true_theta, deterministic = TRUE, seed = 1)
}

# A tiny fit function (test-style), so the example runs without external engines:
fit_fun <- function(bt_data, ...) {
  bt_data <- as.data.frame(bt_data)
  ids <- sort(unique(c(bt_data[[1]], bt_data[[2]])))
  wins <- stats::setNames(rep(0L, length(ids)), ids)
  n_j <- stats::setNames(rep(0L, length(ids)), ids)
  for (i in seq_len(nrow(bt_data))) {
    a <- as.character(bt_data[[1]][i])
    b <- as.character(bt_data[[2]][i])
    r <- as.numeric(bt_data[[3]][i])
    if (is.finite(r)) {
      if (r == 1) wins[a] <- wins[a] + 1L else wins[b] <- wins[b] + 1L
      n_j[a] <- n_j[a] + 1L
      n_j[b] <- n_j[b] + 1L
    }
  }
  theta <- as.numeric(wins - stats::median(wins))
  se <- 1 / sqrt(pmax(1L, as.integer(n_j)))
  list(
    engine = "mock",
    reliability = 0.95,
    theta = tibble::tibble(ID = names(wins), theta = theta, se = se),
    diagnostics = list(sepG = 3.5)
  )
}

out <- bt_run_adaptive(
  samples = samples,
  judge_fun = judge_fun,
  fit_fun = fit_fun,
  engine = "mock",
  fit_engine_running = "bt",
  round_size = 1,
  init_round_size = 1,
  max_rounds = 1,
  final_refit = FALSE,
  return_diagnostics = FALSE,
  rel_se_p90_target = NA_real_,
  rel_se_p90_min_improve = NA_real_
)
out$rounds

}
