% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bt_run_adaptive.R
\name{bt_run_adaptive}
\alias{bt_run_adaptive}
\title{Run a round-based adaptive BT workflow end-to-end}
\usage{
bt_run_adaptive(
  samples,
  judge_fun,
  initial_results = NULL,
  judge = NULL,
  engine = "sirt",
  fit_verbose = FALSE,
  return_diagnostics = TRUE,
  include_residuals = FALSE,
  round_size = 50,
  init_round_size = round_size,
  max_rounds = 50,
  se_probs = c(0.5, 0.9, 0.95),
  fit_bounds = c(0.7, 1.3),
  reliability_target = 0.9,
  sepG_target = 3,
  rel_se_p90_target = 0.3,
  rel_se_p90_min_improve = 0.01,
  max_item_misfit_prop = 0.05,
  max_judge_misfit_prop = 0.05,
  k_neighbors = 10,
  min_judgments = 12,
  forbid_repeats = TRUE,
  balance_positions = TRUE,
  seed_pairs = NULL,
  reverse_audit = FALSE,
  reverse_pct = 0.1,
  n_reverse = NULL,
  reverse_seed = NULL,
  fit_fun = fit_bt_model,
  build_bt_fun = build_bt_data,
  ...
)
}
\arguments{
\item{samples}{A tibble/data.frame with columns \code{ID} and \code{text}.}

\item{judge_fun}{A function that accepts a tibble of pairs (columns
\code{ID1}, \code{text1}, \code{ID2}, \code{text2}) and returns a tibble of
results with columns \code{ID1}, \code{ID2}, and \code{better_id}. If
\code{judge} is provided, the returned tibble must also include that column.
\code{better_id} may be returned as \code{ID1}/\code{ID2} or positional labels like
\code{SAMPLE_1}/\code{SAMPLE_2} (also \code{1}/\code{2}); these are normalized to the
corresponding IDs.}

\item{initial_results}{Optional tibble/data.frame of already-scored pairs
with columns \code{ID1}, \code{ID2}, \code{better_id} (and optional judge column).
If \code{NULL} (default) or empty, the runner will generate an initial bootstrap
set of \code{init_round_size} random pairs and score them first.}

\item{judge}{Optional character scalar. If supplied, this is treated as the name
of a column in results identifying the judge/backend/model. It is passed to
\code{\link{build_bt_data}} so that sirt can use judge information when available.}

\item{engine}{Character scalar passed through to \code{fit_fun} as its \code{engine}
argument. Default \code{"sirt"}.}

\item{fit_verbose}{Logical passed to \code{fit_fun}. Default \code{FALSE}.}

\item{return_diagnostics}{Logical passed to \code{fit_fun}. Default \code{TRUE}.}

\item{include_residuals}{Logical passed to \code{fit_fun}. Default \code{FALSE}.}

\item{round_size}{Integer number of new pairs to propose each adaptive round.}

\item{init_round_size}{Integer number of bootstrap pairs to score before the
first model fit (only used when \code{initial_results} is empty). Default:
\code{round_size}.}

\item{max_rounds}{Integer maximum number of adaptive rounds (excluding the bootstrap
scoring step). Default 50.}

\item{se_probs, fit_bounds}{Passed to \code{\link{bt_adaptive_round}}.}

\item{reliability_target, sepG_target, rel_se_p90_target, rel_se_p90_min_improve, }{max_item_misfit_prop,max_judge_misfit_prop Passed to \code{\link{bt_adaptive_round}}.}

\item{k_neighbors, min_judgments, forbid_repeats, balance_positions}{Passed to
\code{\link{bt_adaptive_round}} (and ultimately \code{\link{select_adaptive_pairs}}).}

\item{seed_pairs}{Optional integer. When provided, pair generation is reproducible
across runs and the RNG state is restored to its prior value (or returned to
"uninitialized" if it was missing).}

\item{reverse_audit}{Logical; if \code{TRUE}, run a post-stop reverse-order audit.
Default \code{FALSE}.}

\item{reverse_pct}{Optional proportion (0..1) of already-judged unique pairs to
reverse and re-score for the audit. Ignored if \code{n_reverse} is provided.}

\item{n_reverse}{Optional integer number of pairs to reverse for the audit.}

\item{reverse_seed}{Optional integer seed for selecting the audit subset.}

\item{fit_fun}{Function used to fit the model. Default \code{\link{fit_bt_model}}.
This is primarily a test hook; most users should keep the default.}

\item{build_bt_fun}{Function used to build BT data from results. Default
\code{\link{build_bt_data}}.}

\item{...}{Additional arguments passed through to \code{fit_fun}.}
}
\value{
A list with elements:
\describe{
\item{results}{All accumulated forward-direction results (ID1, ID2, better_id, ...).}
\item{bt_data}{BT data built from \code{results}.}
\item{fits}{List of per-round fit objects (one per adaptive round).}
\item{rounds}{A tibble summarizing each adaptive round (metrics + stop flag).}
\item{pairs_bootstrap}{Pairs used in the bootstrap scoring step (may be empty).}
\item{reverse_audit}{NULL unless \code{reverse_audit=TRUE}; then contains audit
pairs, reverse results, and consistency outputs.}
}
}
\description{
This exported runner implements the core adaptive loop:
\enumerate{
\item propose pairs (initial random bootstrap, then adaptive),
\item score pairs using a provided judge function (LLM/human/simulator),
\item append results,
\item fit a BT model,
\item compute stopping metrics and decide whether to stop,
\item repeat until stopping criteria are met or \code{max_rounds} is reached.
}
}
\details{
\strong{No reverse-order checks during adaptive sampling.}
Optionally, after stopping (or hitting \code{max_rounds}), you can run a
post-hoc reverse-order audit on a random subset of already-judged pairs and
compute forward-vs-reverse consistency via \code{\link{compute_reverse_consistency}}.

The default modeling function is \code{\link{fit_bt_model}} and the default
stopping+pairing helper is \code{\link{bt_adaptive_round}}.
}
\examples{
# Minimal self-contained example that does not require sirt:
samples <- tibble::tibble(
  ID = c("A", "B", "C", "D"),
  text = paste("text", c("A", "B", "C", "D"))
)

# A tiny "judge" simulator (deterministic by latent ability):
true_theta <- c(A = 2, B = 1, C = 0, D = -1)
judge_fun <- function(pairs) {
  simulate_bt_judge(pairs, true_theta = true_theta, deterministic = TRUE, seed = 1)
}

# A tiny fit function (test-style), so the example runs without external engines:
fit_fun <- function(bt_data, ...) {
  bt_data <- as.data.frame(bt_data)
  ids <- sort(unique(c(bt_data[[1]], bt_data[[2]])))
  wins <- stats::setNames(rep(0L, length(ids)), ids)
  n_j <- stats::setNames(rep(0L, length(ids)), ids)
  for (i in seq_len(nrow(bt_data))) {
    a <- as.character(bt_data[[1]][i])
    b <- as.character(bt_data[[2]][i])
    r <- as.numeric(bt_data[[3]][i])
    if (is.finite(r)) {
      if (r == 1) wins[a] <- wins[a] + 1L else wins[b] <- wins[b] + 1L
      n_j[a] <- n_j[a] + 1L
      n_j[b] <- n_j[b] + 1L
    }
  }
  theta <- as.numeric(wins - stats::median(wins))
  se <- 1 / sqrt(pmax(1L, as.integer(n_j)))
  list(
    engine = "mock",
    reliability = 0.95,
    theta = tibble::tibble(ID = names(wins), theta = theta, se = se),
    diagnostics = list(sepG = 3.5)
  )
}

out <- bt_run_adaptive(
  samples = samples,
  judge_fun = judge_fun,
  fit_fun = fit_fun,
  engine = "mock",
  round_size = 2,
  init_round_size = 2,
  max_rounds = 2,
  rel_se_p90_target = NA_real_,
  rel_se_p90_min_improve = NA_real_
)
out$rounds

}
