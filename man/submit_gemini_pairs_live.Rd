% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gemini_live.R
\name{submit_gemini_pairs_live}
\alias{submit_gemini_pairs_live}
\title{Live Google Gemini comparisons for a tibble of pairs}
\usage{
submit_gemini_pairs_live(
  pairs,
  model,
  trait_name,
  trait_description,
  prompt_template = set_prompt_template(),
  api_key = NULL,
  thinking_level = c("low", "medium", "high", "minimal"),
  temperature = NULL,
  top_p = NULL,
  top_k = NULL,
  max_output_tokens = NULL,
  api_version = "v1beta",
  verbose = TRUE,
  status_every = 1L,
  progress = interactive(),
  include_raw = FALSE,
  validate = FALSE,
  validate_strict = FALSE,
  include_thoughts = FALSE,
  save_path = NULL,
  return_mode = c("all", "new"),
  parallel = FALSE,
  workers = 1,
  ...
)
}
\arguments{
\item{pairs}{Tibble/data frame with columns \code{ID1}, \code{text1}, \code{ID2}, \code{text2}.}

\item{model}{Gemini model name (e.g. \code{"gemini-3-pro-preview"}).}

\item{trait_name}{Trait name.}

\item{trait_description}{Trait description.}

\item{prompt_template}{Prompt template string, typically from
\code{\link[=set_prompt_template]{set_prompt_template()}}.}

\item{api_key}{Optional Gemini API key.}

\item{thinking_level}{One of \code{"minimal"}, \code{"low"}, \code{"medium"}, or \code{"high"}.
Controls the maximum depth of internal reasoning for Gemini models. If not
supplied, defaults to \code{"minimal"} for \code{model = "gemini-3-flash-preview"} and
\code{"low"} otherwise. Currently, the Gemini REST API only supports \code{"Minimal"},
\code{"Low"}, and \code{"High"} values; \code{"medium"} is mapped internally to \code{"High"}
with a warning.}

\item{temperature}{Optional numeric temperature; forwarded to
\code{\link[=gemini_compare_pair_live]{gemini_compare_pair_live()}}. See Gemini docs; if \code{NULL} (default), the
model uses its own default.}

\item{top_p}{Optional numeric; forwarded to \code{\link[=gemini_compare_pair_live]{gemini_compare_pair_live()}}.}

\item{top_k}{Optional numeric; forwarded to \code{\link[=gemini_compare_pair_live]{gemini_compare_pair_live()}}.}

\item{max_output_tokens}{Optional integer; forwarded to
\code{\link[=gemini_compare_pair_live]{gemini_compare_pair_live()}}.}

\item{api_version}{API version; default \code{"v1beta"}.}

\item{verbose}{Logical; print status/timing every \code{status_every} pairs.}

\item{status_every}{Integer; how often to print status (default 1 = every
pair).}

\item{progress}{Logical; show a text progress bar.}

\item{include_raw}{Logical; if \code{TRUE}, each row of the returned tibble will
include a \code{raw_response} list-column with the parsed JSON body.
Note: Raw responses are not saved to the incremental CSV file.}

\item{validate}{Logical; if \code{TRUE}, attach a compact \code{validation_report} computed by \code{\link[=validate_backend_results]{validate_backend_results()}}.}

\item{validate_strict}{Logical; only used when \code{validate = TRUE}. If \code{TRUE}, enforce validity by calling \code{\link[=validate_pairwise_results]{validate_pairwise_results()}} (errors on invalid winners). If \code{FALSE} (default), validation is report-only.}

\item{include_thoughts}{Logical; if \code{TRUE}, requests explicit reasoning
output from Gemini and stores it in the \code{thoughts} column of the result,
mirroring \code{\link[=gemini_compare_pair_live]{gemini_compare_pair_live()}}.}

\item{save_path}{Character string; optional file path (e.g., "output.csv")
to save results incrementally. If the file exists, the function reads it
to identify and skip pairs that have already been processed (resume mode).
Requires the \code{readr} package.}

\item{return_mode}{Character string; controls what is returned when
\code{save_path} is used. \code{"all"} (default) returns the full accumulated
checkpoint plus new results; \code{"new"} returns only results created during
the current call (recommended for adaptive workflows).}

\item{parallel}{Logical; if \code{TRUE}, enables parallel processing using
\code{future.apply}. Requires the \code{future} and \code{future.apply}
packages.}

\item{workers}{Integer; the number of parallel workers (threads) to use if
\code{parallel = TRUE}. Defaults to 1.
\strong{Guidance:} Start conservatively (e.g., 2-4 workers) to avoid hitting
HTTP 429 errors, as Gemini rate limits can be strict depending on your tier.}

\item{...}{Reserved for future extensions; passed through to
\code{\link[=gemini_compare_pair_live]{gemini_compare_pair_live()}} (but \code{thinking_budget} is ignored there).}
}
\value{
A list containing two elements:
\describe{
\item{results}{A tibble with one row per successfully processed pair.}
\item{failed_pairs}{A tibble containing the rows from \code{pairs} that
failed to process (due to API errors or timeouts), along with an
\code{error_message} column.}
}
}
\description{
This is a robust row-wise wrapper around \code{\link[=gemini_compare_pair_live]{gemini_compare_pair_live()}}. It
takes a tibble of pairs (\code{ID1} / \code{text1} / \code{ID2} / \code{text2}), submits each
pair to the Google Gemini API, and collects the results.
}
\details{
This function offers:
\itemize{
\item \strong{Parallel Processing:} Uses the \code{future} package to process
multiple pairs simultaneously.
\item \strong{Incremental Saving:} Writes results to a CSV file as they complete.
If the process is interrupted, re-running the function with the same
\code{save_path} will automatically skip pairs that were already successfully processed.
\item \strong{Error Separation:} Returns valid results and failed pairs separately,
making it easier to debug or retry specific failures.
}
}
\examples{
# Requires:
# - GEMINI_API_KEY set in your environment
# - Internet access
# - Billable Gemini API usage
\dontrun{
# Example pair data
pairs <- tibble::tibble(
  ID1   = c("S01", "S03"),
  text1 = c("Text 1", "Text 3"),
  ID2   = c("S02", "S04"),
  text2 = c("Text 2", "Text 4")
)

td <- trait_description("overall_quality")
tmpl <- set_prompt_template()

# 1. Sequential execution with incremental saving
res_seq <- submit_gemini_pairs_live(
  pairs             = pairs,
  model             = "gemini-3-pro-preview",
  trait_name        = td$name,
  trait_description = td$description,
  prompt_template   = tmpl,
  save_path         = "results_gemini_seq.csv"
)

# 2. Parallel execution (faster)
res_par <- submit_gemini_pairs_live(
  pairs             = pairs,
  model             = "gemini-3-pro-preview",
  trait_name        = td$name,
  trait_description = td$description,
  prompt_template   = tmpl,
  save_path         = "results_gemini_par.csv",
  parallel          = TRUE,
  workers           = 4
)

# Inspect results
head(res_par$results)
}

}
