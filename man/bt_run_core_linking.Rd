% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bt_run_core_linking.R
\name{bt_run_core_linking}
\alias{bt_run_core_linking}
\title{Run a core-linking batch workflow end-to-end (round-based)}
\usage{
bt_run_core_linking(
  samples,
  batches,
  core_ids = NULL,
  core_method = c("embeddings", "token_stratified", "random"),
  core_size = 30,
  embeddings = NULL,
  judge_fun,
  initial_results = NULL,
  judge = NULL,
  fit_fun = fit_bt_model,
  build_bt_fun = build_bt_data,
  engine = "sirt",
  fit_verbose = FALSE,
  return_diagnostics = TRUE,
  include_residuals = FALSE,
  round_size = 50,
  max_rounds_per_batch = 50,
  within_batch_frac = 0.25,
  core_audit_frac = 0.1,
  k_neighbors = 10,
  min_judgments = 12,
  forbid_repeats = TRUE,
  balance_positions = TRUE,
  se_probs = c(0.5, 0.9, 0.95),
  fit_bounds = c(0.7, 1.3),
  reliability_target = 0.9,
  sepG_target = 3,
  rel_se_p90_target = 0.3,
  rel_se_p90_min_improve = 0.01,
  max_item_misfit_prop = 0.05,
  max_judge_misfit_prop = 0.05,
  core_theta_cor_target = NA_real_,
  core_theta_spearman_target = NA_real_,
  core_max_abs_shift_target = NA_real_,
  core_p90_abs_shift_target = NA_real_,
  drift_reference = c("previous_round", "baseline"),
  seed = NULL,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{samples}{A tibble/data.frame with columns \code{ID} and \code{text}. \code{ID}
must be unique and non-missing.}

\item{batches}{A non-empty list where each element is a character vector of IDs to
be added in that batch. IDs must be present in \code{samples$ID}.}

\item{core_ids}{Optional character vector of core IDs. If \code{NULL}, core IDs are
selected using \code{\link{select_core_set}}.}

\item{core_method}{Core selection method used when \code{core_ids} is \code{NULL}.
Passed to \code{\link{select_core_set}}.}

\item{core_size}{Core size used when \code{core_ids} is \code{NULL}.}

\item{embeddings}{Optional embedding matrix for \code{core_method = "embeddings"}.}

\item{judge_fun}{Function that accepts a tibble of pairs with columns \code{ID1},
\code{text1}, \code{ID2}, \code{text2} and returns a tibble with columns
\code{ID1}, \code{ID2}, \code{better_id}. If \code{judge} is provided, the output
must also include that column.}

\item{initial_results}{Optional tibble of previously-judged results (same schema as
output of \code{judge_fun}). Used as a warm start.}

\item{judge}{Optional string naming the judge column to pass through to modeling.}

\item{fit_fun}{Function that fits a BT model from BT data (default \code{\link{fit_bt_model}}).}

\item{build_bt_fun}{Function to build BT data from results (default \code{\link{build_bt_data}}).}

\item{engine}{Passed to \code{fit_fun} when \code{fit_fun = fit_bt_model}.}

\item{fit_verbose}{Passed to \code{fit_fun} when \code{fit_fun = fit_bt_model}.}

\item{return_diagnostics}{Passed to \code{fit_fun} when \code{fit_fun = fit_bt_model}.}

\item{include_residuals}{Passed to \code{fit_fun} when \code{fit_fun = fit_bt_model}.}

\item{round_size}{Target number of pairs proposed per round (per batch).}

\item{max_rounds_per_batch}{Maximum rounds to run for each batch.}

\item{within_batch_frac}{Fraction of each round allocated to new↔new comparisons.}

\item{core_audit_frac}{Fraction of each round allocated to core↔core audit comparisons.}

\item{k_neighbors}{Passed to \code{\link{select_core_link_pairs}}.}

\item{min_judgments}{Passed to \code{\link{select_core_link_pairs}}.}

\item{forbid_repeats}{Forbid repeat unordered pairs across the entire run.}

\item{balance_positions}{Balance positions (ID1 vs ID2) when proposing pairs.}

\item{se_probs}{Passed to \code{\link{bt_stop_metrics}}.}

\item{fit_bounds}{Passed to \code{\link{bt_stop_metrics}} when diagnostics are available.}

\item{reliability_target}{Passed to \code{\link{bt_should_stop}}.}

\item{sepG_target}{Passed to \code{\link{bt_should_stop}}.}

\item{rel_se_p90_target}{Passed to \code{\link{bt_should_stop}}.}

\item{rel_se_p90_min_improve}{Passed to \code{\link{bt_should_stop}}.}

\item{max_item_misfit_prop}{Passed to \code{\link{bt_should_stop}}.}

\item{max_judge_misfit_prop}{Passed to \code{\link{bt_should_stop}}.}

\item{core_theta_cor_target}{Optional drift guardrail for Pearson correlation
(default \code{NA} = disabled).}

\item{core_theta_spearman_target}{Optional drift guardrail for Spearman correlation
(default \code{NA} = disabled).}

\item{core_max_abs_shift_target}{Optional drift guardrail for maximum abs shift
(default \code{NA} = disabled).}

\item{core_p90_abs_shift_target}{Optional drift guardrail for p90 abs shift
(default \code{NA} = disabled).}

\item{drift_reference}{Drift reference for computing core drift metrics:
\code{"previous_round"} compares to the prior round's fit; \code{"baseline"} compares
to a fixed baseline fit.}

\item{seed}{Optional integer seed used to make pair proposal reproducible across runs.}

\item{verbose}{Logical; print minimal progress per batch/round.}

\item{...}{Additional arguments forwarded to \code{fit_fun}.}
}
\value{
A list with:
\describe{
\item{core_ids}{Core linking IDs used.}
\item{batches}{Normalized batches list.}
\item{results}{All judged results (canonicalized \code{better_id}).}
\item{fits}{List of per-round fits (including bootstrap/warm start).}
\item{final_fits}{Named list of final fit per batch (plus \code{"bootstrap"}).}
\item{metrics}{Tibble of stop metrics per round (computed on batch new IDs).}
\item{batch_summary}{One row per batch: rounds used, stop reason, counts.}
}
}
\description{
This runner orchestrates a multi-wave (batch) workflow using a stable core
linking set. For each batch of new items, it runs a round-based loop:
propose pairs (core↔new + new↔new + optional core↔core audit), score the pairs
via \code{judge_fun}, append results, fit a BT model, compute stop metrics on
the batch's new IDs (optionally including core drift), then stop or continue.
}
\details{
Stopping is typically driven by precision on the batch's new items (e.g.,
\code{rel_se_p90}) and can be gated by core drift guardrails
(via \code{core_*_target} thresholds).
}
\examples{
# CRAN-safe example (no APIs, no sirt): deterministic simulated judging + mock fit.
samples <- tibble::tibble(
  ID = LETTERS[1:6],
  text = paste("text", LETTERS[1:6])
)
batches <- list(batch1 = c("D", "E"), batch2 = c("F"))
core_ids <- c("A", "B", "C")

# Deterministic simulated judge (always picks the higher true theta)
true_theta <- c(A = 2, B = 1, C = 0, D = -1, E = -2, F = -3)
judge_fun <- function(pairs) simulate_bt_judge(pairs, true_theta, deterministic = TRUE)

# Tiny mock fit: returns required structure (ID/theta/se)
round <- 0
mock_fit <- function(bt_data, ...) {
  round <<- round + 1
  ids <- sort(unique(c(bt_data$object1, bt_data$object2)))
  se <- rep(max(0.60 - 0.15 * round, 0.05), length(ids))
  list(
    engine = "mock",
    reliability = NA_real_,
    theta = tibble::tibble(ID = ids, theta = seq_along(ids), se = se),
    diagnostics = list(sepG = NA_real_)
  )
}

out <- bt_run_core_linking(
  samples = samples,
  batches = batches,
  core_ids = core_ids,
  judge_fun = judge_fun,
  fit_fun = mock_fit,
  engine = "mock",
  round_size = 8,
  max_rounds_per_batch = 3,
  # disable thresholds requiring sirt diagnostics for this example
  reliability_target = NA_real_,
  sepG_target = NA_real_,
  max_item_misfit_prop = NA_real_,
  max_judge_misfit_prop = NA_real_,
  rel_se_p90_target = 0.80,
  verbose = FALSE
)
out$batch_summary

}
