% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptive_pairs.R
\name{select_adaptive_pairs}
\alias{select_adaptive_pairs}
\title{Select adaptive pairs for the next round of comparisons}
\usage{
select_adaptive_pairs(
  samples,
  theta,
  existing_pairs = NULL,
  embedding_neighbors = NULL,
  n_pairs,
  k_neighbors = 10,
  min_judgments = 12,
  repeat_policy = "reverse_only",
  repeat_cap = 1L,
  repeat_frac = 0.05,
  repeat_n = NULL,
  repeat_guard_min_degree = 1L,
  repeat_guard_largest_component_frac = 0.9,
  forbid_repeats = NULL,
  balance_positions = TRUE,
  embed_far_k = 0,
  embed_quota_frac = 0.25,
  candidate_pool_cap = Inf,
  per_anchor_cap = Inf,
  w_embed = 1,
  embed_score_mode = "rank_decay",
  return_internal = FALSE,
  seed = NULL
)
}
\arguments{
\item{samples}{A tibble/data frame with columns \code{ID} and \code{text}.}

\item{theta}{A tibble/data frame with columns \code{ID}, \code{theta}, and \code{se}
(typically \code{bt_fit$theta} from \code{\link{fit_bt_model}}).}

\item{existing_pairs}{Optional data frame containing previously judged pairs.
Supported formats:
\itemize{
\item \code{ID1}, \code{ID2} (e.g., pairs table or LLM results)
\item \code{object1}, \code{object2} (e.g., BT data)
}
If \code{NULL} (default), the function assumes no prior pairs.}

\item{embedding_neighbors}{Optional embedding-based neighbor lists used to
augment candidate generation. This can be either:
\itemize{
\item a named list mapping each ID to a character vector of neighbor IDs, or
\item a matrix/data.frame with \code{rownames} equal to IDs and neighbor IDs
stored in columns.
}
When provided, these candidates are added on top of the theta-neighborhood
candidates controlled by \code{k_neighbors}.}

\item{n_pairs}{Integer number of new pairs to return for the next round.}

\item{k_neighbors}{Integer number of adjacent neighbors (in sorted-theta order).
Use \code{NULL} or \code{Inf} to consider all neighbors. Default is 10.}

\item{min_judgments}{Integer minimum desired number of judgments per item.
Items below this threshold are prioritized. Default is 12.}

\item{repeat_policy}{Character repeat planning policy. Options:
\itemize{
\item \code{"none"}: do not plan repeat checks.
\item \code{"reverse_only"}: plan a subset of opposite-direction repeats for
eligible unordered pairs (A,B).
\item \code{"forbid_unordered"}: convenience alias that behaves like the
legacy \code{forbid_repeats = TRUE} (no planned repeats and forbids
selecting unordered repeats from the candidate pool).
}}

\item{repeat_cap}{Non-negative integer cap on the number of planned repeat
pairs per unordered pair key. For \code{repeat_policy = "reverse_only"}, each
unordered pair is eligible for at most \code{repeat_cap} planned reverse
repeats.}

\item{repeat_frac}{Numeric in \code{[0, 1]}. Target fraction of the requested
\code{n_pairs} that should be reserved for repeat checks (when eligible
repeat pairs exist).}

\item{repeat_n}{Optional non-negative integer. If provided, overrides
\code{repeat_frac} and targets this many planned repeat pairs.}

\item{repeat_guard_min_degree}{Integer. Guard for enabling repeat planning:
do not plan repeats until the minimum graph degree across IDs is at least
this value.}

\item{repeat_guard_largest_component_frac}{Numeric in \code{[0, 1]}. Guard for
enabling repeat planning: do not plan repeats until the largest connected
component contains at least this fraction of IDs.}

\item{forbid_repeats}{Logical; if \code{TRUE} (default), do not return pairs
that have already appeared in \code{existing_pairs} (unordered).}

\item{balance_positions}{Logical; if \code{TRUE} (default), orient each selected
pair so that items with more historical appearances in position 1 (ID1) are
more likely to be placed in position 2 (ID2), and vice versa.}

\item{embed_far_k}{Integer; number of additional "far" candidates to sample
per item (uniformly at random) in addition to theta/embedding neighbors.}

\item{embed_quota_frac}{Numeric in \code{[0, 1]}. Minimum fraction of selected pairs
that should come from embedding-neighbor candidates when
\code{embedding_neighbors} is provided. Set to 0 to disable the quota.
Default is 0.25.}

\item{candidate_pool_cap}{Optional cap on the candidate pool size after
scoring/constraints. Use \code{Inf} (default) for no cap.}

\item{per_anchor_cap}{Optional cap on the number of candidates retained per
anchor item (in theta-sorted order) after scoring/constraints. Use
\code{Inf} (default) for no cap.}

\item{w_embed}{Numeric weight for an embedding-neighbor bonus term in the
scoring function. Default is 1 (embeddings influence both candidate
generation and scoring when available).}

\item{embed_score_mode}{Character; how to compute the embedding bonus when
\code{w_embed != 0}. Options are \code{"binary_neighbor"} and
\code{"rank_decay"}.}

\item{return_internal}{Logical; if \code{TRUE}, return a list with
\code{$pairs}, \code{$diagnostics}, and intermediate candidate tables.}

\item{seed}{Optional integer seed for reproducibility. If \code{NULL} (default),
the current RNG state is used and not modified.}
}
\value{
A tibble with columns \code{ID1}, \code{text1}, \code{ID2}, \code{text2}.
Extra columns are not returned, to keep the output directly compatible with
\code{\link{submit_llm_pairs}}.

The returned tibble may include attributes used for diagnostics:
\itemize{
\item \code{attr(out, "planned_repeat_pairs")}: a tibble of repeat pairs
planned under \code{repeat_policy} (may be empty).
\item \code{attr(out, "pairing_diagnostics")}: a one-row tibble of pairing
counts/caps/guard outcomes.
}
}
\description{
This helper proposes a new set of pairs for a round-based adaptive workflow.
It uses current BT estimates (\code{theta} and \code{se}) to prioritize pairs
that are expected to be most informative (roughly: pairs with predicted win
probability near 0.5) while also prioritizing items that have not yet been
judged \code{min_judgments} times.
}
\details{
Candidate pairs are generated efficiently by sorting items by \code{theta} and
considering only \code{k_neighbors} adjacent items for each item. This avoids
enumerating all \code{N*(N-1)/2} pairs and scales to large \code{N}.

The function can also:
\itemize{
\item forbid repeated pairings (unordered) across rounds,
\item balance positions (ID1 vs ID2) to reduce positional bias,
\item accept existing pairs in either \code{ID1/ID2} or \code{object1/object2} format.
}
}
\examples{
samples <- tibble::tibble(
  ID = c("A", "B", "C", "D"),
  text = paste("Sample", c("A", "B", "C", "D"))
)

theta <- tibble::tibble(
  ID = c("A", "B", "C", "D"),
  theta = c(0.0, 0.1, 2.0, 2.1),
  se = c(0.5, 0.5, 0.3, 0.3)
)

# First round: no existing pairs
select_adaptive_pairs(samples, theta, n_pairs = 2, seed = 1)

# Later: forbid repeats against existing pairs
existing <- tibble::tibble(ID1 = "A", ID2 = "B")
select_adaptive_pairs(samples, theta, existing_pairs = existing, n_pairs = 2, seed = 1)

}
