% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptive_pairs.R
\name{select_adaptive_pairs}
\alias{select_adaptive_pairs}
\title{Select adaptive pairs for the next round of comparisons}
\usage{
select_adaptive_pairs(
  samples,
  theta,
  existing_pairs = NULL,
  embedding_neighbors = NULL,
  n_pairs,
  k_neighbors = 10,
  min_judgments = 12,
  forbid_repeats = TRUE,
  balance_positions = TRUE,
  embed_far_k = 0,
  seed = NULL
)
}
\arguments{
\item{samples}{A tibble/data frame with columns \code{ID} and \code{text}.}

\item{theta}{A tibble/data frame with columns \code{ID}, \code{theta}, and \code{se}
(typically \code{bt_fit$theta} from \code{\link{fit_bt_model}}).}

\item{existing_pairs}{Optional data frame containing previously judged pairs.
Supported formats:
\itemize{
\item \code{ID1}, \code{ID2} (e.g., pairs table or LLM results)
\item \code{object1}, \code{object2} (e.g., BT data)
}
If \code{NULL} (default), the function assumes no prior pairs.}

\item{embedding_neighbors}{Optional embedding-based neighbor lists used to
augment candidate generation. This can be either:
\itemize{
\item a named list mapping each ID to a character vector of neighbor IDs, or
\item a matrix/data.frame with \code{rownames} equal to IDs and neighbor IDs
stored in columns.
}
When provided, these candidates are added on top of the theta-neighborhood
candidates controlled by \code{k_neighbors}.}

\item{n_pairs}{Integer number of new pairs to return for the next round.}

\item{k_neighbors}{Integer number of adjacent neighbors (in sorted-theta order).
Use \code{NULL} or \code{Inf} to consider all neighbors. Default is 10.}

\item{min_judgments}{Integer minimum desired number of judgments per item.
Items below this threshold are prioritized. Default is 12.}

\item{forbid_repeats}{Logical; if \code{TRUE} (default), do not return pairs
that have already appeared in \code{existing_pairs} (unordered).}

\item{balance_positions}{Logical; if \code{TRUE} (default), orient each selected
pair so that items with more historical appearances in position 1 (ID1) are
more likely to be placed in position 2 (ID2), and vice versa.}

\item{embed_far_k}{Integer; number of additional "far" candidates to sample
per item (uniformly at random) in addition to theta/embedding neighbors.}

\item{seed}{Optional integer seed for reproducibility. If \code{NULL} (default),
the current RNG state is used and not modified.}
}
\value{
A tibble with columns \code{ID1}, \code{text1}, \code{ID2}, \code{text2}.
Extra columns are not returned, to keep the output directly compatible with
\code{\link{submit_llm_pairs}}.
}
\description{
This helper proposes a new set of pairs for a round-based adaptive workflow.
It uses current BT estimates (\code{theta} and \code{se}) to prioritize pairs
that are expected to be most informative (roughly: pairs with predicted win
probability near 0.5) while also prioritizing items that have not yet been
judged \code{min_judgments} times.
}
\details{
Candidate pairs are generated efficiently by sorting items by \code{theta} and
considering only \code{k_neighbors} adjacent items for each item. This avoids
enumerating all \code{N*(N-1)/2} pairs and scales to large \code{N}.

The function can also:
\itemize{
\item forbid repeated pairings (unordered) across rounds,
\item balance positions (ID1 vs ID2) to reduce positional bias,
\item accept existing pairs in either \code{ID1/ID2} or \code{object1/object2} format.
}
}
\examples{
samples <- tibble::tibble(
  ID = c("A", "B", "C", "D"),
  text = paste("Sample", c("A", "B", "C", "D"))
)

theta <- tibble::tibble(
  ID = c("A", "B", "C", "D"),
  theta = c(0.0, 0.1, 2.0, 2.1),
  se = c(0.5, 0.5, 0.3, 0.3)
)

# First round: no existing pairs
select_adaptive_pairs(samples, theta, n_pairs = 2, seed = 1)

# Later: forbid repeats against existing pairs
existing <- tibble::tibble(ID1 = "A", ID2 = "B")
select_adaptive_pairs(samples, theta, existing_pairs = existing, n_pairs = 2, seed = 1)

}
