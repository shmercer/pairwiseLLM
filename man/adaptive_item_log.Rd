% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptive_print.R
\name{adaptive_item_log}
\alias{adaptive_item_log}
\title{Adaptive item log accessor.}
\usage{
adaptive_item_log(state, refit_id = NULL, stack = FALSE)
}
\arguments{
\item{state}{Adaptive state.}

\item{refit_id}{Optional refit index.}

\item{stack}{When TRUE, stack all refits.}
}
\value{
A tibble of item-level summaries. When \code{stack = FALSE}, one row
per item for the selected refit. When \code{stack = TRUE}, one row per item
per refit with \code{refit_id} identifying source refit.
}
\description{
Adaptive item log accessor.
}
\details{
\code{item_log} stores per-item posterior summaries by refit.
The underlying state stores a list of refit tables; this
accessor can return one refit table (default: most recent) or stack all
refits into a single tibble.

In linking mode, raw and global summaries are kept separate:
\itemize{
\item \code{theta_raw_eap}: within-set scale summary (from Phase A artifacts
when available).
\item \code{theta_global_eap} and \code{theta_global_sd}: global-scale
summaries after spoke transform application. These are typed \code{NA}
when required spoke transform parameters are unavailable at that refit.
}
}
\examples{
state <- adaptive_rank_start(c("a", "b", "c"), seed = 1)
adaptive_item_log(state)

}
\seealso{
\code{\link[=adaptive_get_logs]{adaptive_get_logs()}}, \code{\link[=summarize_items]{summarize_items()}}, \code{\link[=adaptive_round_log]{adaptive_round_log()}}

Other adaptive logs: 
\code{\link{adaptive_get_logs}()},
\code{\link{adaptive_results_history}()},
\code{\link{adaptive_round_log}()},
\code{\link{adaptive_step_log}()}
}
\concept{adaptive logs}
