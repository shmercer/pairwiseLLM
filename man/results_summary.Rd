% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/results_summary.R
\name{results_summary}
\alias{results_summary}
\title{Summarize a pairwise results table}
\usage{
results_summary(
  results,
  id1_col = "ID1",
  id2_col = "ID2",
  winner_col = "better_id",
  judge_col = NULL,
  compute_reverse = TRUE,
  normalize_winner = FALSE,
  strict = FALSE
)
}
\arguments{
\item{results}{A data frame or tibble of pairwise results.}

\item{id1_col, id2_col}{Column names giving the first and second item IDs.}

\item{winner_col}{Column name giving the winner ID (i.e., the better item).}

\item{judge_col}{Optional column name identifying the judge/model/annotator.}

\item{compute_reverse}{Logical; if \code{TRUE}, attempt to compute forward-vs-reverse
consistency when both orderings exist.}

\item{normalize_winner}{Logical; if \code{TRUE}, attempt to normalize common winner
tokens (e.g., \code{"SAMPLE_1"}, \code{"SAMPLE_2"}, \code{"1"}, \code{"2"}) into
the corresponding IDs. Unsupported tokens remain invalid.}

\item{strict}{Logical; if \code{TRUE}, validate inputs using
\code{\link{validate_pairwise_results}} (errors on invalid winners and other
violations). If \code{FALSE} (default), the function is report-only.}
}
\value{
A list with components:
\describe{
\item{\code{overall}}{A one-row data frame of overall counts.}
\item{\code{reverse}}{A list (or \code{NULL}) with a \code{summary} data frame and
\code{details}, as produced by \code{\link{compute_reverse_consistency}}.}
\item{\code{judge}}{A list (or \code{NULL}) containing per-judge summaries.}
}
}
\description{
\code{results_summary()} computes quick, human-friendly diagnostics for a
pairwise results table (typically the output of a judging backend or a runner).

It is designed to be \emph{non-blocking} by default: in non-strict mode it
reports counts of missing or invalid winners instead of erroring. When
\code{strict = TRUE}, the function calls \code{\link{validate_pairwise_results}}
to enforce validity (while still allowing rows with missing winners).
}
\details{
The summary is returned as a list with up to three components:
\describe{
\item{\code{overall}}{One-row data frame with coverage and basic validity counts
(rows, unique IDs, unique unordered pairs, missing winners, invalid winners).}
\item{\code{reverse}}{If \code{compute_reverse = TRUE} and both pair orderings are
present, a list returned by \code{\link{compute_reverse_consistency}}. Note that
reverse-consistency is computed using only rows with a valid winner. Pairs where
the per-direction majority vote is tied are excluded by
\code{\link{compute_reverse_consistency}}.}
\item{\code{judge}}{If \code{judge_col} is provided and present, a list containing
per-judge summaries from \code{\link{judge_summary}} and flags for missing judge
values.}
}
}
\examples{
res <- tibble::tibble(
  ID1 = c("A", "B", "A", "B"),
  ID2 = c("B", "A", "C", "C"),
  better_id = c("A", "A", "C", NA_character_)
)

# Non-strict: report missing/invalid winners without erroring
s <- results_summary(res, compute_reverse = TRUE, strict = FALSE)
s$overall

# Strict: enforce validity (still allows missing winners)
s2 <- results_summary(res, compute_reverse = TRUE, strict = TRUE)

}
\seealso{
\code{\link{validate_pairwise_results}}, \code{\link{judge_summary}},
\code{\link{compute_reverse_consistency}}
}
