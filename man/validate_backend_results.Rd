% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/validate_backend_results.R
\name{validate_backend_results}
\alias{validate_backend_results}
\title{Validate and summarize backend-parsed pairwise results}
\usage{
validate_backend_results(
  results,
  backend = NULL,
  id1_col = "ID1",
  id2_col = "ID2",
  winner_col = "better_id",
  judge_col = NULL,
  normalize_winner = FALSE,
  strict = FALSE,
  return_report = FALSE
)
}
\arguments{
\item{results}{A data frame or tibble of parsed backend outputs.}

\item{backend}{Optional backend label to include in the report (e.g., \code{"openai_live"}).}

\item{id1_col, id2_col}{Column names for the first and second item IDs.}

\item{winner_col}{Column name for the winner ID.}

\item{judge_col}{Optional column identifying the judge/model/annotator.}

\item{normalize_winner}{Logical; if \code{TRUE}, normalize common winner tokens.}

\item{strict}{Logical; if \code{TRUE}, enforce validity and error on violations
(using \code{\link{validate_pairwise_results}}). If \code{FALSE} (default),
produce a report without erroring on invalid winners.}

\item{return_report}{Logical; if \code{TRUE}, return a list with \code{data} and
\code{report}. If \code{FALSE}, return the (possibly normalized) data.}
}
\value{
If \code{return_report = FALSE}, returns a tibble/data.frame (possibly with
normalized winners when \code{normalize_winner = TRUE}).

If \code{return_report = TRUE}, returns a list with:
\describe{
\item{\code{data}}{The validated/normalized data (same rows as input).}
\item{\code{report}}{A list containing counts and flags: total rows, missing/invalid
winners, missing IDs, and (when present) backend error counts.}
}
}
\description{
\code{validate_backend_results()} is a convenience wrapper for validating the
output of a judging backend (LLM or human) after parsing, and for producing a
compact report about parse/validation health.

Unlike \code{\link{validate_pairwise_results}}, this function defaults to a
\emph{report-only} mode that does not error on invalid winners. This is useful
when you want to measure backend quality (e.g., parse failures) without
interrupting a pipeline. Set \code{strict = TRUE} to enforce validity.
}
\details{
The function checks for required ID and winner columns, counts missing/invalid
winners, and (when present) counts backend error indicators such as
\code{status_code} and \code{error_message}. It can optionally validate judge
columns (e.g., model name) via \code{judge_col}.

Winner validation follows the same rule as \code{\link{validate_pairwise_results}}:
non-missing winners must exactly match \code{ID1} or \code{ID2}. If
\code{normalize_winner = TRUE}, the function also recognizes common winner tokens
such as \code{"SAMPLE_1"}, \code{"SAMPLE_2"}, \code{"1"}, and \code{"2"} and maps
them to the corresponding IDs.
}
\examples{
res <- tibble::tibble(
  ID1 = c("A", "A", "B"),
  ID2 = c("B", "C", "C"),
  better_id = c("SAMPLE_1", "2", NA_character_),
  status_code = c(200L, 200L, 500L),
  error_message = c(NA, NA, "Server error")
)

# Report-only mode (default): does not error on invalid rows
out <- validate_backend_results(res, backend = "demo", normalize_winner = TRUE, return_report = TRUE)
out$report$n_invalid_winner

# Strict mode: enforce validity (errors on invalid winners)
\dontrun{
validate_backend_results(res, strict = TRUE)
}

}
\seealso{
\code{\link{validate_pairwise_results}}, \code{\link{results_summary}}
}
