% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_rank_centrality.R
\name{fit_rank_centrality}
\alias{fit_rank_centrality}
\title{Fit Rank Centrality scores from pairwise comparison data}
\usage{
fit_rank_centrality(
  bt_data,
  ids = NULL,
  smoothing = 0.5,
  damping = 0,
  max_iter = 5000,
  tol = 1e-10,
  return_transition = FALSE,
  verbose = FALSE
)
}
\arguments{
\item{bt_data}{A data frame or tibble with columns \code{object1},
\code{object2}, and \code{result} (numeric 0/1), as produced by
\code{\link{build_bt_data}}. A 4th column (e.g., \code{judge}) is allowed and
ignored.}

\item{ids}{Optional character vector of item IDs to include. If \code{NULL}
(default), uses the union of \code{object1} and \code{object2} in
\code{bt_data}.}

\item{smoothing}{Non-negative numeric scalar. Adds a symmetric pseudo-count
to each pair to avoid empirical probabilities of exactly 0 or 1. For each
unordered pair, the smoothed estimate is
\deqn{\hat{p}_{ij} = (w_{ij} + s) / (n_{ij} + 2s),}
where \eqn{w_{ij}} is the number of wins by \eqn{i} over \eqn{j},
\eqn{n_{ij}} is the total number of comparisons, and \eqn{s} is
\code{smoothing}. Defaults to \code{0.5}.}

\item{damping}{Numeric scalar in \eqn{[0, 1)}. If greater than 0, mixes the
transition matrix with a uniform teleport term to ensure ergodicity:
\deqn{P \leftarrow (1 - \alpha) P + \alpha \mathbf{1}\mathbf{1}^T / n,}
where \eqn{\alpha} is \code{damping}. Defaults to \code{0}.}

\item{max_iter}{Maximum number of iterations for the power method used to
compute the stationary distribution. Defaults to \code{5000}.}

\item{tol}{Convergence tolerance for the power method. Defaults to
\code{1e-10}.}

\item{return_transition}{Logical. If \code{TRUE}, include the transition
matrix \code{P} in the returned object. Defaults to \code{FALSE}.}

\item{verbose}{Logical. If \code{TRUE}, print basic convergence information.
Defaults to \code{FALSE}.}
}
\value{
A list with components:
\itemize{
\item \code{engine}: \code{"rank_centrality"}.
\item \code{reliability}: \code{NA_real_} (Rank Centrality does not provide
an MLE reliability measure).
\item \code{theta}: a tibble with columns \code{ID}, \code{theta},
and \code{pi}. \code{theta} is \code{log(pi)} centered to have mean zero.
\item \code{diagnostics}: a list containing graph and numerical diagnostics
(degree statistics, number of connected components, spectral gap if
computable, power-method iterations, and convergence error).
\item \code{P}: (optional) the transition matrix if
\code{return_transition = TRUE}.
}
}
\description{
Rank Centrality is a spectral / random-walk based estimator for ranking items
from pairwise comparisons. It is particularly useful on sparse comparison
graphs and can be used as a stable running estimator during adaptive data
collection.
}
\details{
The method constructs a Markov chain on the comparison graph. For each
compared pair \eqn{(i, j)}, let \eqn{\hat{p}_{ij}} be the empirical probability
that item \eqn{i} wins against item \eqn{j}. Rank Centrality defines transition
probabilities from \eqn{i} to neighbor \eqn{j} proportional to
\eqn{1 - \hat{p}_{ij}} (the probability that \eqn{j} beats \eqn{i}), then
normalizes by the degree of \eqn{i}. The stationary distribution of the chain
is used as a score; \code{theta} is reported as \code{log(pi)} centered to have
mean zero.

This function accepts Bradley-Terry style comparison data (as produced by
\code{\link{build_bt_data}}). It is designed to be robust to sparse graphs
and extreme win/loss patterns by using optional smoothing and an optional
teleport/damping term (similar to PageRank) to ensure a unique stationary
distribution.
}
\examples{
# A simple transitive toy example: A > B > C
bt_data <- tibble::tibble(
  object1 = c("A", "A", "B"),
  object2 = c("B", "C", "C"),
  result  = c(1, 1, 1)
)

fit <- fit_rank_centrality(bt_data)
fit$theta

# Disconnected graph (two components)
bt_data2 <- tibble::tibble(
  object1 = c("A", "C"),
  object2 = c("B", "D"),
  result  = c(1, 1)
)
fit2 <- fit_rank_centrality(bt_data2, damping = 0.1)
fit2$diagnostics$n_components

}
