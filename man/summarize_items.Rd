% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptive_summaries.R
\name{summarize_items}
\alias{summarize_items}
\title{Summarize adaptive items}
\usage{
summarize_items(
  state,
  posterior = NULL,
  refit = NULL,
  bind = FALSE,
  top_n = NULL,
  sort_by = c("rank_mean", "theta_mean", "theta_sd", "degree", "pos_A_rate"),
  include_optional = TRUE
)
}
\arguments{
\item{state}{An \code{adaptive_state} or list containing adaptive logs.}

\item{posterior}{Optional \code{item_log_list} (list of item log tables) or
an item log table. When \code{NULL}, uses \code{state$logs$item_log_list}
when available.}

\item{refit}{Optional refit index. When \code{NULL}, the most recent refit is
returned; when set, the \code{k}-th refit is returned.}

\item{bind}{Logical; when \code{TRUE}, stack all refits into a single table.}

\item{top_n}{Optional positive integer; return only the top \code{n} rows
after sorting.}

\item{sort_by}{Column used for sorting. Defaults to \code{"rank_mean"}.}

\item{include_optional}{Logical; include optional diagnostic columns.}
}
\value{
A tibble with one row per item per refit. Columns reflect the
canonical item log schema (for example \code{refit_id}, \code{ID},
\code{theta_mean}, \code{rank_mean}, \code{deg}, and \code{posA_prop}).
Rank percentiles summarize per-draw induced ranks (lower is better). When
\code{include_optional = FALSE}, optional columns such as repeated-pair or
adjacency diagnostics are dropped if present.
}
\description{
Build an item-level diagnostics summary from the canonical item logs. This
is a pure view and does not recompute posterior quantities or exposure
metrics.
}
\details{
Rank percentiles are computed from the per-draw induced ranks (lower is
better). Rank uncertainty grows when draws disagree on the ordering. Degree
and position exposure metrics summarize how frequently each item was shown
and whether it appeared as the first option (A position). When
\code{refit = NULL}, the most recent refit is returned; when
\code{refit = k}, the \code{k}-th refit is returned. When \code{bind = TRUE},
all refits are stacked into a single table and \code{refit} must be
\code{NULL}.
}
\examples{
# summarize_items() expects an item_log_list (list of per-refit item tables).
# This example constructs a minimal logs object that matches what adaptive runs emit.

item_log_1 <- tibble::tibble(
  refit_id = 1L,
  ID = c("A", "B", "C"),
  theta_mean = c(0.4, 0.1, -0.2),
  theta_sd = c(0.2, 0.3, 0.25),
  rank_mean = c(1.2, 2.1, 2.7),
  degree = c(10L, 9L, 8L),
  pos_A_rate = c(0.55, 0.50, 0.48)
)

item_log_2 <- dplyr::mutate(
  item_log_1,
  refit_id = 2L,
  theta_mean = theta_mean + c(0.1, 0.05, 0.02),
  rank_mean = rank_mean + c(-0.1, 0.0, 0.1)
)

logs <- list(item_log_list = list(item_log_1, item_log_2))

# Default returns the most recent refit:
summarize_items(logs)

# Select a specific refit:
summarize_items(logs, refit = 1)

# Stack all refits into one table:
summarize_items(logs, bind = TRUE)

# Sort and take the top rows:
summarize_items(logs, sort_by = "rank_mean", top_n = 2)

}
