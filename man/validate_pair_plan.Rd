% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/validate_pair_plan.R
\name{validate_pair_plan}
\alias{validate_pair_plan}
\title{Validate a proposed pair plan}
\usage{
validate_pair_plan(
  pairs,
  id1_col = "ID1",
  id2_col = "ID2",
  ids = NULL,
  allow_self = FALSE,
  allow_duplicates = FALSE,
  strict = FALSE,
  return_report = FALSE
)
}
\arguments{
\item{pairs}{A data frame or tibble containing proposed pairs.}

\item{id1_col, id2_col}{Column names for the first and second item IDs.}

\item{ids}{Optional character vector of allowed IDs. If provided, all IDs in
\code{pairs} must be contained in \code{ids}.}

\item{allow_self}{Logical; if \code{FALSE} (default), error/warn when \code{ID1 == ID2}.}

\item{allow_duplicates}{Logical; if \code{FALSE} (default), error/warn when the same
unordered pair appears more than once.}

\item{strict}{Logical; if \code{TRUE}, violations throw an error; if \code{FALSE},
violations produce warnings.}

\item{return_report}{Logical; if \code{TRUE}, return a list with \code{data} and
\code{report}. If \code{FALSE}, return \code{pairs} (invisibly).}
}
\value{
If \code{return_report = FALSE}, returns \code{pairs} (invisibly).
If \code{return_report = TRUE}, returns a list with:
\describe{
\item{\code{data}}{The input \code{pairs} (unchanged).}
\item{\code{report}}{A list of diagnostics, including counts of violations,
per-ID appearance counts, and simple position-balance summaries.}
}
}
\description{
\code{validate_pair_plan()} checks a data frame of \emph{proposed} (unjudged)
pairs before sending them to a judge (human or LLM). It is intended to catch
common issues early (self-pairs, duplicates, missing IDs, IDs not in a known
set) and to provide lightweight diagnostics on coverage and position balance.
}
\details{
The function can be used in two styles:
\itemize{
\item \strong{Strict validation} (\code{strict = TRUE}): any violation errors.
\item \strong{Report-only} (\code{strict = FALSE}): violations trigger warnings
and (optionally) a report can be returned via \code{return_report = TRUE}.
}

Duplicate checking is performed on \emph{unordered} pairs using a key computed
from \code{pmin(ID1, ID2)} and \code{pmax(ID1, ID2)}, so both \code{(A, B)} and
\code{(B, A)} count as duplicates unless \code{allow_duplicates = TRUE}.
}
\examples{
pairs <- tibble::tibble(
  ID1 = c("A", "A", "B"),
  ID2 = c("B", "C", "A")
)

# Report-only: returns a report and warns if needed
out <- validate_pair_plan(pairs, return_report = TRUE)
out$report$n_rows

# Strict mode: errors on self-pairs / duplicates / invalid IDs
pairs2 <- tibble::tibble(ID1 = c("A", "A"), ID2 = c("A", "B"))
\dontrun{
validate_pair_plan(pairs2, strict = TRUE)
}

}
