% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bt_adaptive_round.R
\name{bt_adaptive_round}
\alias{bt_adaptive_round}
\title{Run one adaptive round: compute metrics, decide stopping, and propose next pairs}
\usage{
bt_adaptive_round(
  samples,
  fit,
  existing_pairs = NULL,
  prev_metrics = NULL,
  round_size,
  se_probs = c(0.5, 0.9, 0.95),
  fit_bounds = c(0.7, 1.3),
  stopping_tier = c("strong", "good", "very_strong"),
  reliability_target = 0.9,
  sepG_target = 3,
  rel_se_p90_target = 0.3,
  rel_se_p90_min_improve = 0.01,
  max_item_misfit_prop = 0.05,
  max_judge_misfit_prop = 0.05,
  k_neighbors = 10,
  min_judgments = 12,
  repeat_policy = "reverse_only",
  repeat_cap = 1L,
  repeat_frac = 0.05,
  repeat_n = NULL,
  repeat_guard_min_degree = 1L,
  repeat_guard_largest_component_frac = 0.9,
  forbid_repeats = NULL,
  balance_positions = TRUE,
  embedding_neighbors = NULL,
  embed_far_k = 0,
  embed_quota_frac = 0.25,
  candidate_pool_cap = Inf,
  per_anchor_cap = Inf,
  w_embed = 1,
  embed_score_mode = "rank_decay",
  seed = NULL
)
}
\arguments{
\item{samples}{A tibble/data frame with columns \code{ID} and \code{text}.}

\item{fit}{A list returned by \code{\link{fit_bt_model}} containing at least
\code{$theta} with columns \code{ID}, \code{theta}, and \code{se}.}

\item{existing_pairs}{Optional data frame of previously judged pairs (used for
repeat prevention, judgment counts, and position balancing). Supported formats:
\itemize{
\item \code{ID1}, \code{ID2}
\item \code{object1}, \code{object2}
}}

\item{prev_metrics}{Optional one-row tibble of prior-round metrics (as returned
by \code{\link{bt_stop_metrics}}), used for stability-based stopping.}

\item{round_size}{Integer number of new pairs to propose for the next round.}

\item{se_probs}{Numeric vector of probabilities for SE quantiles passed to
\code{\link{bt_stop_metrics}}. Default: \code{c(0.5, 0.9, 0.95)}.}

\item{fit_bounds}{Numeric length-2 vector giving lower/upper acceptable}

\item{stopping_tier}{Preset stopping thresholds to use (good/strong/very_strong).
infit/outfit bounds. Default: \code{c(0.7, 1.3)}.}

\item{reliability_target}{Optional numeric. If not \code{NA}, require
\code{metrics$reliability >= reliability_target}.}

\item{sepG_target}{Optional numeric. If not \code{NA}, require
\code{metrics$sepG >= sepG_target}.}

\item{rel_se_p90_target}{Optional numeric. If not \code{NA}, require
\code{metrics$rel_se_p90 <= rel_se_p90_target} to meet the precision target.}

\item{rel_se_p90_min_improve}{Optional numeric. If not \code{NA} and \code{prev_metrics}
is provided, allow stopping when improvement in \code{rel_se_p90} stalls.}

\item{max_item_misfit_prop}{Optional numeric. If not \code{NA}, require
\code{metrics$item_misfit_prop <= max_item_misfit_prop} (when available).}

\item{max_judge_misfit_prop}{Optional numeric. If not \code{NA}, require
\code{metrics$judge_misfit_prop <= max_judge_misfit_prop} (when available).}

\item{k_neighbors}{Integer number of adjacent neighbors (in theta order) to consider
in candidate generation. Passed to \code{\link{select_adaptive_pairs}}.}

\item{min_judgments}{Integer minimum desired number of judgments per item.
Passed to \code{\link{select_adaptive_pairs}}.}

\item{forbid_repeats}{Logical; passed to \code{\link{select_adaptive_pairs}}.}

\item{balance_positions}{Logical; passed to \code{\link{select_adaptive_pairs}}.}

\item{embedding_neighbors}{Optional embedding-based neighbor lists used to
augment candidate generation. This should be a named list mapping each ID to
a character vector of neighbor IDs (or a matrix/data.frame with rownames = IDs
and neighbor IDs in columns). Passed to \code{\link{select_adaptive_pairs}}.}

\item{embed_far_k}{Integer; number of additional "far" candidates to sample
per item when embedding_neighbors is provided. Passed to
select_adaptive_pairs().}

\item{embed_quota_frac}{Numeric in \code{[0, 1]}. Minimum fraction of selected pairs
that should come from embedding-neighbor candidates. Passed to
select_adaptive_pairs().}

\item{candidate_pool_cap}{Global cap on candidate pairs (after constraints and
optional per-anchor capping). Passed to select_adaptive_pairs().}

\item{per_anchor_cap}{Optional cap on candidate pairs retained per anchor
item (after scoring). Passed to select_adaptive_pairs().}

\item{w_embed}{Non-negative numeric weight for embedding-neighbor candidates
in scoring. Passed to select_adaptive_pairs().}

\item{embed_score_mode}{Character; how to compute the embedding score when
w_embed > 0. Passed to select_adaptive_pairs().}

\item{seed}{Optional integer seed for reproducibility; passed to \code{\link{select_adaptive_pairs}}.}
}
\value{
A list with:
\describe{
\item{metrics}{One-row tibble from \code{\link{bt_stop_metrics}}.}
\item{decision}{List from \code{\link{bt_should_stop}} containing \code{stop}, \code{details}, and \code{improve}.}
\item{pairs_next}{Tibble of proposed pairs with columns \code{ID1}, \code{text1}, \code{ID2}, \code{text2}.}
}
}
\description{
This helper is intended for round-based adaptive comparative judgement workflows.
Given a current Bradleyâ€“Terry fit (typically from \code{\link{fit_bt_model}}),
it computes stopping metrics, applies stopping rules, and (if not stopping)
proposes a new set of pairs for the next round using \code{\link{select_adaptive_pairs}}.
}
\details{
This function does not fit the model itself; it expects you to provide a fit.
A typical loop is:
\enumerate{
\item Fit a BT model using current results
\item Call \code{bt_adaptive_round()} to get \code{pairs_next}
\item Score \code{pairs_next} (LLM/humans), append results, repeat
}
}
\examples{
samples <- tibble::tibble(
  ID = c("A", "B", "C"),
  text = c("text A", "text B", "text C")
)

# Mock fit object (for example/documentation)
fit <- list(
  engine = "mock",
  reliability = 0.95,
  theta = tibble::tibble(
    ID = c("A", "B", "C"),
    theta = c(0.0, 0.1, 0.2),
    se = c(0.5, 0.5, 0.5)
  ),
  diagnostics = list(sepG = 3.5)
)

out <- bt_adaptive_round(samples, fit, round_size = 2, seed = 1)
out$decision$stop
out$pairs_next

}
