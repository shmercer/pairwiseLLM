% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adaptive_run.R
\name{adaptive_rank_resume}
\alias{adaptive_rank_resume}
\title{Resume an adaptive ranking run}
\usage{
adaptive_rank_resume(
  state = NULL,
  state_path = NULL,
  mode = c("live", "batch"),
  submission_info = NULL,
  submission = list(),
  adaptive = list(),
  seed = NULL
)
}
\arguments{
\item{state}{An \code{adaptive_state} object. If \code{NULL},
\code{state_path} must be provided.}

\item{state_path}{Optional path to a saved \code{adaptive_state} RDS file.}

\item{mode}{Submission mode. Either \code{"live"} or \code{"batch"}.}

\item{submission_info}{Metadata returned by \code{adaptive_rank_start()} or
prior calls to \code{adaptive_rank_resume()}.}

\item{submission}{A list of arguments passed through to
\code{submit_llm_pairs()} (live) or \code{llm_resume_multi_batches()} /
\code{llm_submit_pairs_multi_batch()} (batch).}

\item{adaptive}{A list of adaptive configuration overrides. See
\code{adaptive_rank_start()} for supported keys.}

\item{seed}{Optional integer seed for deterministic scheduling.}
}
\value{
A list with:
\describe{
\item{state}{The updated \code{adaptive_state}.}
\item{state_path}{Path where the state was saved (batch mode only).}
\item{submission_info}{Metadata for subsequent resumes.}
\item{next_action}{List with \code{action} and \code{reason}.}
\item{new_results}{The newly ingested results, if any.}
\item{final_summary}{Cached summary payload, if produced.}
}
}
\description{
Resume from a saved or in-memory \code{adaptive_state}, ingesting only newly
observed outcomes (using \code{pair_uid} to deduplicate) and scheduling the
next batch of pairs. This function supports both live and batch modes and
may need to be called multiple times until the run completes.
}
\details{
Incremental ingestion is idempotent: results are filtered to previously
unseen \code{pair_uid}s before updating \code{history_results}. This ensures
that cumulative backend returns can be resumed safely without double-counting.
Resume may schedule new comparisons if the budget and constraints allow.

Model variants, stopping gates, and canonical outputs follow the same rules
as \code{adaptive_rank_start()}. Refits occur when at least \code{refit_B}
new results are available (or when the first refit is needed).
}
\examples{
# Minimal synthetic setup (no submission).
samples <- tibble::tibble(
  ID = c("S1", "S2", "S3"),
  text = c("alpha", "bravo", "charlie")
)
state <- pairwiseLLM:::adaptive_state_new(
  samples = samples,
  config = list(d1 = 2L, M1_target = 2L, budget_max = 4L)
)

# Stop-criteria presets (copy/paste ready)
adaptive_fast <- list(
  v3 = list(
    eap_reliability_min = 0.80,
    min_ess_bulk = 150,
    max_rhat = 1.05
  )
)
adaptive_high_conf <- list(
  v3 = list(
    eap_reliability_min = 0.95,
    min_ess_bulk = 1000,
    max_rhat = 1.01
  )
)
adaptive_debug <- list(
  v3 = list(
    progress = TRUE,
    progress_level = "full"
  )
)

\dontrun{
# Batch resume (state loaded from disk)
resume_out <- adaptive_rank_resume(
  state_path = "adaptive_runs/adaptive_state.rds",
  mode = "batch",
  submission_info = batch_out$submission_info,
  adaptive = adaptive_fast,
  seed = 123
)

# Live resume (state kept in memory)
resume_out <- adaptive_rank_resume(
  state = start_out$state,
  mode = "live",
  submission_info = start_out$submission_info,
  adaptive = adaptive_high_conf,
  seed = 123
)
}

}
